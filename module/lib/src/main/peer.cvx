{}


;; TODO. Explicit support for setting poll delay?


;;;;;;;;;; Helpers


(defn dir

  [option+]

  (.fs.resolve (or (:dir option+)
                   "./")))



(defn url


  ([option+]

   (url (:host option+)
        (:port option+)))


  ([host port]
    (str (or host
             "localhost")
         ":"
         (or port
             .peer.default.port))))


;;;;;;;;;; Starting peers


(defn resume


  ([kp.seed]

   (resume kp.seed
           nil))

  ([kp.seed option+]

   (when-not (.fs.exists? (str (or (:dir option+)
                                   "./")
                               "/store.etch"))
     (fail :SHELL.PEER
           "Etch file missing"))
   (start kp.seed
          option+
          (fn [kp]
            (let [pubkey      (.kp.pubkey kp)
                  config.path (.fs.resolve (or (:config.path option+)
                                               (str (dir option+) "/config.cvx")))
                  config      (do
                                (.log.info* (str "Reading peer configuration from '" config.path "'"))
                                (first (.file.read config.path)))]
              (let [config-2    (merge config
                                       option+)
                    remote.host (:remote.host config-2)
                    remote.port (:remote.port config-2)]
                (.log.info* (str "Resuming peer on " (url config-2)))
                [(if (and remote.host
                          remote.port)
                   (do
                     (.log.info* (str "Syncing against "
                                      (url remote.host
                                           remote.port)))
                     (.peer.init.sync kp
                                      config-2))
                   (do
                     (.log.info* "No sync")
                     (.peer.init kp
                                 config-2)))
                                 nil]))))))



(defn start

  [kp.seed option+ peer.init]

  (let [dir-              (dir option+)
        etch.path.target  (.fs.resolve (str dir- "/store.etch"))
        etch.path.current (.db.path)]
    (when (and etch.path.current
               (not (= etch.path.current
                       etch.path.target)))
      (fail :SHELL.PEER
            "Etch instance already open at a different location"))
      (let [log.stream   (.file.stream.out (or (:log.path option+)
                                              (str dir- "/log.cvx"))
                                           {:append? true})
            _            (do
                           (.log.out.set log.stream)
                           (.log.info* (str "Opening Etch instance at '" etch.path.target "'"))
                           (.db.open etch.path.target))
            kp           (do
                           (.log.info* "Creating key pair from seed")
                           (.kp.create kp.seed))
            peer.option+ (:peer+ option+)
            [peer
             config]     (do
                           (.log.info* "Initializing peer")
                           (peer.init kp))]
      (when config
        (let [path.config  (.fs.resolve (or (:config.path option+)
                                            (str dir- "/config.cvx")))]
          (.log.info* (str "Storing peer configuration at '" path.config "'"))
          (.file.write path.config
                       config)))
      (.log.info* "Starting peer")
      (.peer.start peer)
      {:dir        dir-
       :key-pair   kp
       :log.stream log.stream
       :peer       peer})))



(defn start.genesis

   ;; TODO. Helper for randomizing stakes?


  ([kp.seed]

   (genesis kp.seed
            nil))


  ([kp.seed option+]

   (start kp.seed
          option+
          (fn [kp]
            (let [peer.option+   (:peer+ option+)
                  pubkey         (.kp.pubkey kp)
                  state          (do
                                   (.log.info* "Creating genesis state")
                                   (.state.genesis
                                     {:each-peer `(fn [peer]
                                                    (.log.info* (str "Preparing state for peer controlled by " (:controller peer)))
                                                    (let [pubkey (:key peer)]
                                                      (set-peer-data pubkey
                                                                     {:url (str (or (:host peer)
                                                                                    "localhost")
                                                                                ":"
                                                                                (or (:port peer)
                                                                                    .peer.default.port))})
                                                      (set-peer-stake pubkey
                                                                      (:stake peer))))
                                      :peer+     peer.option+
                                      :pubkey+   (if (empty? peer.option+)
                                                   [pubkey]
                                                   (assoc (map :key
                                                               peer.option+)
                                                          0
                                                          pubkey))}))
                  prepare-state  (:prepare-state option+)
                  state-2        (if prepare-state
                                   (do
                                     (.log.info* "Preparing genesis state")
                                     (second (.state.tmp*
                                               (.state.core.vanilla (prepare-state state)))))
                                   state)
                  peer.0.option+ (first peer.option+)
                  host           (or (:host peer.0.option+)
                                     "localhost")
                  port           (or (:port peer.0.option+)
                                     .peer.default.port)
                  config         {:host     host
                                  :port     port
                                  :root-key (:root-key option+)}]
              (.log.info* "Initializing genesis peer")
              (.log.info* (str "Peer will run on " (url peer.0.option+)))
              [(.peer.init kp
                           (assoc config
                                  :state
                                  state-2))
               config])))))



(defn start.syncer


  [kp.seed option+]

  (start kp.seed
         option+
         (fn [kp]
           (let [host        (or (:host option+)
                                 "localhost")
                 port        (or (:port option+)
                                 .peer.default.port)
                 remote.host (or (:remote.host option+)
                                 "localhost")
                 remote.port (or (:remote.port option+)
                                 .peer.default.port)
                 pubkey      (.kp.pubkey kp)
                 root-key    [pubkey :peer]
                 config      {:host        host
                              :port        port
                              :remote.host remote.host
                              :remote.port remote.port
                              :root-key    (:root-key option+)}]
           (.log.info* "Initializing syncer peer")
           (.log.info* (str "Peer will run on " (url option+)))
           (.log.info* (str "Peer will sync with " remote.host ":" remote.port))
           [(.peer.init.sync kp
                             config)
            config]))))
