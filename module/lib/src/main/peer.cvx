{}


;; TODO. Explicit support for setting poll delay?


;;;;;;;;;; Helpers


(defn dir

  [option+]

  (.fs.resolve (or (:dir option+)
                   "./")))



(defn url


  ([option+]

   (url (:host option+)
        (:port option+)))


  ([host port]
    (str (or host
             "localhost")
         ":"
         (or port
             .peer.default.port))))


;;;;;;;;;; Starting peers


(defn resume


  ([kp.seed]

   (resume kp.seed
           nil))

  ([kp.seed option+]

   (when-not (.fs.exists? (str (or (:dir option+) "./" "/store.etch")))
     (fail :SHELL.PEER
           "Etch file missing"))
   (start kp.seed
          option+
          (fn [kp]
            (let [pubkey (.kp.pubkey kp)
                  config (get (.db.root.read)
                              [pubkey :config])]
              (when-not config
                (fail "Unable to retrieve peer configuration from Etch"))
              (let [type (:type config)
                    url  (url config)]
                (cond
                  ;;
                  (= type
                     :genesis)
                  (.log.info* (str "Resuming genesis peer on " url))
                  ;;
                  (= type
                     :syncer)
                  (.log.info* (str "Resuming syncer peer on " url))
                  ;;
                  (do
                    (.log.fatal* (str "Unknown peer type = " type))
                    (fail :SHELL.PEER
                          "Unknown peer type")))
                (.peer.init kp
                            config)))))))



(defn start

  [kp.seed option+ peer.init]

  (let [dir-              (dir option+)
        etch.path.target  (.fs.resolve (str dir- "/store.etch"))
        etch.path.current (.db.path)]
    (when (and etch.path.current
               (not (= etch.path.current
                       etch.path.target)))
      (fail :SHELL.PEER
            "Etch instance already open at a different location"))
      (let [log.stream   (.file.stream.out (or (:log.path option+)
                                               (str dir- "/log.cvx"))
                                           {:append? true})
          _              (do
                           (.log.out.set log.stream)
                           (.log.info* (str "Opening Etch instance at '" etch.path.target "'"))
                           (.db.open etch.path.target))
          kp             (do
                           (.log.info* "Creating key pair from seed")
                           (.kp.create kp.seed))
          peer.option+   (:peer+ option+)
          peer           (do
                           (.log.info* "Initializing peer")
                           (peer.init kp))]
      (.log.info* "Starting peer")
      (.peer.start peer)
      {:dir        dir-
       :key-pair   kp
       :log.stream log.stream
       :peer       peer})))



(defn start.genesis

   ;; TODO. Helper for randomizing stakes?


  ([kp.seed]

   (genesis kp.seed
            nil))


  ([kp.seed option+]

   (start kp.seed
          option+
          (fn [kp]
            (let [peer.option+   (:peer+ option+)
                  state          (do
                                   (.log.info* "Creating genesis state")
                                   (.state.genesis
                                       {:each-peer `(fn [peer]
                                                      (.log.info* (str "Preparing state for peer controlled by " (:controller peer)))
                                                      (let [pubkey (:key peer)]
                                                        (set-peer-data pubkey
                                                                       {:url (str (or (:host peer)
                                                                                      "localhost")
                                                                                  ":"
                                                                                  (or (:port peer)
                                                                                      .peer.default.port))})
                                                        (set-peer-stake pubkey
                                                                        (:stake peer))))
                                        :peer+     peer.option+
                                        :pubkey+   (map :key
                                                        peer.option+)}))
                  prepare-state  (:prepare-state option+)
                  state-2        (if prepare-state
                                   (do
                                     (.log.info* "Preparing genesis state")
                                     (second (.state.tmp*
                                               (.state.core.vanilla (prepare-state state)))))
                                   state)
                  peer.0.option+ (first peer.option+)
                  host           (or (:host peer.0.option+)
                                     "localhost")
                  port           (or (:port peer.0.option+)
                                     .peer.default.port)
                  pubkey         (.kp.pubkey kp)
                  root-key       [pubkey :peer]
                  config         {:host     host
                                  :port     port
                                  :root-key root-key
                                  :type     :genesis}]
              (.log.info* "Storing peer information in Etch")
              (.db.root.write (assoc (.db.root.read)
                                     [pubkey :config]
                                     config))
              (.log.info* "Initializing genesis peer")
              (.log.info* (str "Peer will run on " (url peer.0.option+)))
              (.peer.init kp
                          (assoc config
                                 :state
                                 state-2)))))))



(defn start.syncer


  [kp.seed option+]

  (start kp.seed
         option+
         (fn [kp]
           (let [host        (or (:host option+)
                                 "localhost")
                 port        (or (:port option+)
                                 .peer.default.port)
                 remote.host (or (:remote.host option+)
                                 "localhost")
                 remote.port (or (:remote.port option+)
                                 .peer.default.port)
                 pubkey      (.kp.pubkey kp)
                 root-key    [pubkey :peer]
                 config      {:host        host
                              :port        port
                              :remote.host remote.host
                              :remote.port remote.port
                              :root-key    root-key}]
           (.log.info* "Storing peer information in Etch")
           (.db.root.write (assoc (.db.root.read)
                                  [pubkey :config]
                                  (assoc config
                                         :type
                                         :syncer)))
           (.log.info* "Initializing syncer peer")
           (.log.info* (str "Peer will run on " (url option+)))
           (.log.info* (str "Peer will sync with " remote.host ":" remote.port))
           (.peer.init.sync kp
                            config)))))
