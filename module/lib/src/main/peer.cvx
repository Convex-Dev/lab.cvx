{}


;;;;;;;;;; Helpers


(defn -start

  ^:private?

  [kp.seed option+ peer.init]

  (let [dir-              (dir option+)
        etch.path.target  (.fs.resolve (str dir- "/store.etch"))
        etch.path.current (.db.path)]
    (when (and etch.path.current
               (not (= etch.path.current
                       etch.path.target)))
      (fail :SHELL.PEER
            "Etch instance already open at a different location"))
      (let [log.stream   (.file.stream.out (or (:log.path option+)
                                              (str dir- "/log.cvx"))
                                           {:append? true})
            _            (do
                           (.log.out.set log.stream)
                           (.log.info* (str "Opening Etch instance at '" etch.path.target "'"))
                           (.db.open etch.path.target))
            kp           (do
                           (.log.info* "Creating key pair from seed")
                           (.kp.create kp.seed))
            [peer
             config]     (do
                           (.log.info* "Initializing peer")
                           (peer.init kp))]
      (when config
        (let [path.config  (.fs.resolve (or (:config.path option+)
                                            (str dir- "/config.cvx")))]
          (.log.info* (str "Storing peer configuration at '" path.config "'"))
          (.file.write path.config
                       config)))
      (.log.info* "Starting peer")
      (.peer.start peer)
      {:dir        dir-
       :key-pair   kp
       :log.stream log.stream
       :peer       peer})))



(defn dir

  [option+]

  (.fs.resolve (or (:dir option+)
                   "./")))



(defn url


  ([option+]

   (url (:host option+)
        (:port option+)))


  ([host port]
    (str (or host
             "localhost")
         ":"
         (or port
             .peer.default.port))))


;;;;;;;;;; Starting peers


(defn resume


  ([kp.seed]

   (resume kp.seed
           nil))

  ([kp.seed option+]

   (when-not (.fs.exists? (str (or (:dir option+)
                                   "./")
                               "/store.etch"))
     (fail :SHELL.PEER
           "Etch file missing"))
   (-start kp.seed
           option+
           (fn [kp]
             (let [pubkey      (.kp.pubkey kp)
                   config.path (.fs.resolve (or (:config.path option+)
                                                (str (dir option+) "/config.cvx")))
                   config      (do
                                 (.log.info* (str "Reading peer configuration from '" config.path "'"))
                                 (first (.file.read config.path)))]
               (let [config-2    (merge config
                                        option+)
                     remote.host (:remote.host config-2)
                     remote.port (:remote.port config-2)]
                 (.log.info* (str "Resuming peer on " (url config-2)))
                 [(if (and remote.host
                           remote.port)
                    (do
                      (.log.info* (str "Syncing against "
                                       (url remote.host
                                            remote.port)))
                      (.peer.init.sync kp
                                       config-2))
                    (do
                      (.log.info* "No sync")
                      (.peer.init kp
                                  config-2)))
                                  nil]))))))



(defn start


  ([kp.seed state]

   (start kp.seed
          state
          nil))


  ([kp.seed state option+]

   (-start kp.seed
           option+
           (fn [kp]
             (let [host   (or (:host option+)
                              "localhost")
                   port   (or (:port option+)
                              .peer.default.port)
                   config {:host          host
                           :n.max.sibling (:n.max.sibling option+)
                           :port          port
                           :poll-delay    (:poll-delay option+)
                           :root-key      (:root-key option+)}]
               (.log.info* (str "Peer will run on " (url option+)))
               [(.peer.init kp
                            (assoc config
                                   :state
                                   state))
                config])))))



(defn start.sync


  ([kp.seed]

   (start.sync kp.seed
               nil))


  ([kp.seed option+]

   (-start kp.seed
           option+
           (fn [kp]
             (let [host        (or (:host option+)
                                   "localhost")
                   port        (or (:port option+)
                                   .peer.default.port)
                   remote.host (or (:remote.host option+)
                                   "localhost")
                   remote.port (or (:remote.port option+)
                                   .peer.default.port)
                   config      {:host          host
                                :n.max.sibling (:n.max.sibling option+)
                                :port          port
                                :poll-delay    (:poll-delay option+)
                                :remote.host   remote.host
                                :remote.port   remote.port
                                :root-key      (:root-key option+)}]
             (.log.info* (str "Peer will run on " (url option+)))
             (.log.info* (str "Peer will sync with " remote.host ":" remote.port))
             [(.peer.init.sync kp
                               config)
              config])))))
