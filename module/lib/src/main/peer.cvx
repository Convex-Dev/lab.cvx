{}


;;;;;;;;;; Helpers


(defn -start

  ^:private?

  [kp.seed resuming? option+ peer.init]

  (let [dir-              (dir option+)
        etch.path.target  (.fs.resolve (str dir- "/store.etch"))
        etch.path.current (.db.path)]
    (when (and etch.path.current
               (not (= etch.path.current
                       etch.path.target)))
      (fail :SHELL.PEER
            "Etch instance already open at a different location"))
      (let [log.stream       (.file.stream.out (or (:log.path option+)
                                                  (str dir- "/log.cvx"))
                                               {:append? resuming?})
            etch.path.origin (:etch.origin option+)
            _                (do
                               (.log.out.set log.stream)
                               (.log.info* "Launching peer")
                               (when etch.path.origin
                                 (.log.info* (str "Copying Etch from '" etch.path.origin "'"))
                                 (.fs.copy etch.path.origin
                                           etch.path.target))
                               (.log.info* (str "Opening Etch instance at '" etch.path.target "'"))
                               (.db.open etch.path.target))
            kp               (do
                               (.log.info* "Creating key pair from seed")
                               (.kp.create kp.seed))
            [peer
             config]         (do
                               (.log.info* "Initializing peer")
                               (peer.init kp))]
      (when config
        (let [path.config  (.fs.resolve (or (:config.path option+)
                                            (str dir- "/config.cvx")))]
          (.log.info* (str "Storing peer configuration at '" path.config "'"))
          (.file.write path.config
                       config)))
      (.log.info* "Starting peer")
      (.peer.start peer)
      {:dir        dir-
       :key-pair   kp
       :log.stream log.stream
       :peer       peer})))



(defn dir

  [option+]

  (.fs.resolve (or (:dir option+)
                   "./")))



(defn url


  ([option+]

   (url (:host option+)
        (:port option+)))


  ([host port]
    (str (or host
             "localhost")
         ":"
         (or port
             .peer.default.port))))


;;;;;;;;;; Starting peers


(defn resume


  ([kp.seed]

   (resume kp.seed
           nil))

  ([kp.seed option+]

   (when-not (.fs.exists? (str (or (:dir option+)
                                   "./")
                               "/store.etch"))
     (fail :SHELL.PEER
           "Etch file missing"))
   (-start kp.seed
           true
           option+
           (fn [kp]
             (let [pubkey      (.kp.pubkey kp)
                   config.path (.fs.resolve (or (:config.path option+)
                                                (str (dir option+) "/config.cvx")))
                   config      (do
                                 (.log.info* (str "Reading peer configuration from '" config.path "'"))
                                 (first (.file.read config.path)))]
               (let [config-2    (merge config
                                        option+)
                     remote.host (:remote.host config-2)
                     remote.port (:remote.port config-2)]
                 (.log.info* (str "Resuming peer on " (url config-2)))
                 [(if (and remote.host
                           remote.port)
                    (do
                      (.log.info* (str "Syncing against "
                                       (url remote.host
                                            remote.port)))
                      (.peer.init.sync kp
                                       config-2))
                    (do
                      (.log.info* "No sync")
                      (.peer.init kp
                                  config-2)))
                  nil]))))))



(defn start


  ([kp.seed]

   (start kp.seed
          nil))


  ([kp.seed option+]

   (let [state (:state option+)]
     (-start kp.seed
             false
             (if (str? state)
               (assoc option+
                      :etch.origin
                      state)
               option+)
             (fn [kp]
               (let [host   (or (:host option+)
                                "localhost")
                     port   (or (:port option+)
                                .peer.default.port)
                     config {:host          host
                             :n.max.sibling (:n.max.sibling option+)
                             :port          port
                             :poll-delay    (:poll-delay option+)
                             :root-key      (:root-key option+)}]
                 (.log.info* (str "Peer will run on " (url option+)))
                 [(.peer.init kp
                              (assoc config
                                     :state
                                     (cond
                                       ;;
                                       (nil? state)
                                       (.state.genesis)
                                       ;;
                                       (str? state)
                                       (.db.root.read)
                                       ;;
                                       state)))
                  config]))))))



(defn start.sync


  ([kp.seed]

   (start.sync kp.seed
               nil))


  ([kp.seed option+]

   (-start kp.seed
           false
           option+
           (fn [kp]
             (let [host        (or (:host option+)
                                   "localhost")
                   port        (or (:port option+)
                                   .peer.default.port)
                   remote.host (or (:remote.host option+)
                                   "localhost")
                   remote.port (or (:remote.port option+)
                                   .peer.default.port)
                   config      {:host          host
                                :n.max.sibling (:n.max.sibling option+)
                                :port          port
                                :poll-delay    (:poll-delay option+)
                                :remote.host   remote.host
                                :remote.port   remote.port
                                :root-key      (:root-key option+)}]
             (.log.info* (str "Peer will run on " (url option+)))
             (.log.info* (str "Peer will sync with " remote.host ":" remote.port))
             [(.peer.init.sync kp
                               config)
              config])))))
