{:deploy [$.client.pool (lib client pool)
          $.net         (lib net)]}


;;;;;;;;;;


(defn await

  [promise+]

  (.docoll .a.take
           promise+)
  nil)



(defn start


  ([gen.trx]

   (start gen.trx
          nil))


  ([gen.trx option+]

   (when-not (.db.path)
     (.db.open (.fs.tmp)))
   (.log.info* "Retrieving scenario configuration from peer")
   (let [[n.bucket
          i.bucket]        (or (:bucket option+)
                               [1
                                0])
         i.bucket.last     (dec n.bucket)
         _                 (when-not (<= 0
                                         i.bucket
                                         i.bucket.last)
                             (fail :ARGUMENT
                                   "Bucket index not within range"))
         _                 (do
                             (.log.info* (str "Number of buckets = "
                                              n.bucket))
                             (.log.info* (str "Bucket index = "
                                              i.bucket)))
         n.max-client-fail (or (:n.max-client-fail option+)
                               3)
         config            (.try.resrc* [client (.client.connect option+)
                                                (.client.close client)]
                             (:result (.a.take (.client.query client
                                                              .account.genesis
                                                              'config))))
         _                 (.log.info* [:scenario
                                        config])
         gen.trx-2         (gen.trx config)
         _                 (.log.info* (str "Maximum number of failures per client = "
                                            n.max-client-fail))
         n.user.total      (:n.user config)
         n.user.bucket     (div n.user.total
                                n.bucket)
         n.user            (+ n.user.bucket
                              (if (= i.bucket
                                     i.bucket.last)
                                (rem n.user.total
                                     n.bucket)
                                0))
         base.user.rel     (* i.bucket
                              n.user.bucket)
         base.user         (+ (:base.user config)
                              base.user.rel)
         _                 (.log.info* (str "First user = "
                                            (address base.user)))
         gen.seed          (long (/ 9223372036854775807
                                    n.user.total))
         _                 (.log.info* (str "Connecting " n.user " client(s)"))
         client+           ($.client.pool/connect n.user
                                                  ($.net/url+ option+))]
     (loop [acc    []
            i.user 0]
       (if (< i.user
              n.user)
         (recur (conj acc
                      (.a.do*
                        (let [[ok?
                               x]  (.state.safe*
                                     (let [addr.long (+ base.user
                                                        i.user)
                                           addr      (address addr.long)
                                           client    (nth client+
                                                          (mod i.user
                                                               n.user))
                                           kp        (.kp.create (.kp.seed.dev addr.long))
                                           gen.trx-3 (gen.trx-2 (+ base.user.rel
                                                                   i.user))]
                                       ;(.time.sleep (.gen (.gen.long.uniform 0
                                       ;                                      50)))
                                       (loop [gen.seed-2 (* gen.seed
                                                            i.user)
                                              n.fail     0
                                              sequence   1]
                                         (let [trx  (.kp.sign kp
                                                              (.gen (gen.trx-3 sequence)
                                                                    {:seed gen.seed-2}))
                                               [ok?
                                                x]  (.state.safe*
                                                      (.time.do*
                                                        (.a.take (.client.transact client
                                                                                   trx))))]
                                           (if ok?
                                             (let [[rtt
                                                    result] x]
                                               (.log.info* [:client.result
                                                            (assoc result
                                                                   :address addr
                                                                   :rtt     (/ rtt
                                                                               1e6))])
                                               (let [[ok?
                                                      x]  (.state.safe*
                                                            (if (= (:error result)
                                                                   :SEQUENCE)
                                                              (.a.take (.client.sequence client
                                                                                         addr))
                                                              (inc sequence)))]
                                                 (if ok?
                                                   (recur
                                                     (inc gen.seed-2)
                                                     n.fail
                                                     x)
                                                   (.log.error* [:client.fail.sequence
                                                                 {:address addr}]))))
                                            (do
                                              (.log.error* [:client.fail {:address addr
                                                                          :i.fail  n.fail}])
                                              (if (< n.fail
                                                     n.max-client-fail)
                                                (recur
                                                  gen.seed-2
                                                  (inc n.fail)
                                                  (inc sequence))
                                                (.log.info* [:client.fail.final
                                                             {:address addr}]))))))))]
                          (when-not ok?
                            (.log.error* [:client.exception 
                                          {:address   addr
                                           :exception x}])))))
                (inc i.user))
         acc)))))
