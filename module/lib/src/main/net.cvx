{:doc ["Helpers used when running various types Convex networks"
       "provided in this repository."
       ""
       "See:"
       ""
       "    (lib net local)"
       "    (lib net test)"]}


;;;;;;;;;;


(defn url+

  ^{:doc {:description ["Given the endpoint of a single peers, queries and"
                        "returns a Vector of the endpoints of all the peers"
                        "in the network according to `(:peers *state*)` of the"
                        "current State of the network."
                        ""
                        "A Map of options may be provided:"
                        ""
                        "  :host"
                        "    Host of the peer to query."
                        "    Defaults to `\"localhost\"`."
                        ""
                        "  :port"
                        "    Port of the peer to query."
                        "    Defaults to `.peer.default.port`."]
          :examples    [{:code (url+ {:host "123.42.24.321"})}]
          :signature   [{:params []}
                        {:params [option+]}]}}


  ([]

   (url+ nil))


  ([option+]

   (when-not (.db.path)
     (.db.open (.fs.tmp)))
   (.try.resrc* [client (.client.connect option+)
                        (.client.close client)]
     (let [response (.a.take (.client.query client
                                            .account.genesis
                                            '(mapv (fn [peer]
                                                     (:url (:metadata peer)))
                                                   (values (:peers *state*))))
                           10000
                           :timeout)]
       (when (= response
                :timeout)
         (fail :SHELL.CLIENT
               "Timeout while retrieving peer URLs"))
       (mapv (fn [url]
               (if (nil? url)
                 {:host "localhost"
                  :port .peer.default.port}
                 (let [x (split url
                                \:)
                       n (count x)
                       [host
                        port] (cond
                                ;;
                                (= n
                                   1)
                                [(first x)
                                 nil]
                                ;;
                                (= n
                                   2)
                                [(first x)
                                 (let [port (second x)]
                                   (if (empty? port)
                                     nil
                                     (let [port-2 (first (.reader.form+ port))]
                                       (if (long? port-2)
                                         port-2
                                         (fail :STATE
                                               "Peer port is not a number")))))]
                                ;;
                                (fail :STATE
                                      "Peer URL not standard"))]
                   {:host (if (empty? host)
                            "localhost"
                            host)
                    :port (or port
                              .peer.default.port)})))
             (:result response))))))
