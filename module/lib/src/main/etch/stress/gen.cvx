{:deploy [$.math.stat (lib math stat)]}


;;;;;;;;;; Helpers


(defn gen

  [i.iter gen seed size]

  (.log.info* (str "Iteration " i.iter))
  (.log.info* "Generating data")
  (.gen gen
        {:seed (+ i.iter
                  seed)
         :size size}))
  

;;;;;;;;;; Stress testing


(defn integrity

  [result]

  (let [gen-   (:gen result)
        hash+  (:hash+ result)
        n.iter (:n.iter result)
        seed   (:seed result)
        size   (:size result)]
    (loop [i.iter 0]
      (when (< i.iter
               n.iter)
        (let [hash.target (get hash+
                               i.iter)
              cell        (.db.read hash.target)]
          (if (= cell
                 (gen i.iter
                      gen-
                      seed
                      size))
            (recur (inc i.iter))
            [i.iter
             hash.target
             (hash (encoding cell))]))))))



(defn write

  [option+]

  (when-not (.db.path)
    (.db.open (.fs.tmp)))
  (let [n.iter  (or (:n.iter option+)
                    5)
        gen-    (or (:gen option+)
                    (.gen.vector (.gen.any)
                                 50000))
        db.size (.db.size)
        seed    (or (:seed option+)
                    0)
        size    (or (:size option+)
                    30)]
    (.log.info* (str "Number of iterations = " n.iter))
    (.log.info* (str "Seed = " seed))
    (.log.info* (str "Size = " size))
    (loop [hash+   []
           i.iter  0
           n.nano+ []]
      (if (< i.iter
             n.iter)
        (let [cell    (gen i.iter
                           gen-
                           seed
                           size)
             _        (.log.info* "Persisting generated data")
             [t
              cell-2] (.time.do* (.db.write cell))]
          (recur (conj hash+
                       (hash (encoding cell-2)))
                 (inc i.iter)
                 (conj n.nano+
                       t)))
        {:hash+  hash+
         :gen    gen-
         :n.iter n.iter
         :n.nano (reduce +
                         0
                         n.nano+)
         :seed   seed
         :size   size}))))
