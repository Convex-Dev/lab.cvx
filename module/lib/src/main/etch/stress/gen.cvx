{:deploy [$.math.stat (lib math stat)]}


;;;;;;;;;;


(defn integrity

  []

  (let [n-item  100000      
        target? (fn [x]
                  (and (vector? x)
                       (= (count x)
                          n-item)))
        root    (.db.root.read)
        error+  (reduce (fn [acc [hash x]]
                          (if-let [error (if (target? x)
                                           (let [x-2 (.db.read hash)]
                                             (if (target? x-2)
                                               (if (= x-2
                                                      x)
                                                 nil
                                                 :mismatch)
                                               :bad-read))
                                           :bad-write)]
                            (conj acc
                                  [hash
                                   error])
                            acc))
                        0
                        root)]
    [error+
     (count root)]))



(defn write

  [n.iter gen]

  (when-not (.db.path)
    (.db.open (.fs.tmp)))
  (let [db.size (.db.size)]
    (loop [nano+  []
           i.iter 0]
      (if (< i.iter
             n.iter)
        (let [_     (.log.info* (str "Round " i.iter))
              _     (.log.info* "Generating data")
              x     (.gen gen
                          {:seed i.iter
                           :size 100})
             _      (.log.info* "Persisting generated data")
             [t
              hash] (.time.do*
                      (let [hash (.db.write x)]
                        ;(.db.flush)
                        hash))]
          (recur (conj nano+
                       t)
                 (inc i.iter)))
        (do
          (.db.flush)
          (let [nano     (reduce +
                                 0
                                 nano+)
                byte+    (- (.db.size)
                            db.size)
                bps      (* (/ byte+
                               nano)
                            1e9)

                            ]
            (.log.info* "---")
            (.log.info* (str "Etch growth = " (/ byte+ 1e6) " MB"))
            (.log.info* (str "Speed = " (/ bps 1e6) " MB / second"))
            {:bps  bps
             :nano nano}))))))
