{}


;;;;;;;;;; Helpers


(defn tuple

  [n.long i.iter]

  (loop [v      [i.iter]]
    (if (< (count v) 
           n.long)
      (recur (conj v
                   i.iter))
      v)))



(defn overhead.cycle

  [n.long]

  (let [n.iter 1e6
        [nano
         _]    (.time.do*
                 (loop [i.iter 0]
                   (when (< i.iter
                            n.iter)
                     (tuple n.long
                            i.iter)
                     (recur (inc i.iter)))))]
    (/ nano
       n.iter)))
  

;;;;;;;;;; Stress test


(defn integrity

  [result]

  (let [n.iter (:n.iter result)
        n.long (:n.long result)]
    (.log.info* "Running iterations")
    (loop [i.iter 0]
      (when (< i.iter
               n.iter)
        (let [tuple-      (tuple n.long
                                 i.iter)
              hash.target (hash (encoding tuple-))
              cell        (.db.read hash.target)]
          (if (= cell
                 tuple-)
            (recur (inc i.iter))
            [i.iter
             hash.target
             (hash (encoding cell))]))))))



(defn write

  [option+]

  (let [n.iter (or (:n.iter option+)
                   1000000)
        n.long (or (:n.long option+)
                   8)]
    (when-not (<= 1
                  n.long
                  16)
      (fail :ARGUMENT
            "Number of Longs per tuple must be >= 1 and <= 16"))
    (.log.info* (str "Number of iterations = " n.iter))
    (.log.info* (str "Number of Longs / tuple = " n.long))
    (let [db.size  (.db.size)
          _        (.log.info* "Estimating overhead")
          overhead (overhead.cycle n.long)
          _        (.log.info* (str "Overhead estimation = " overhead " nanos / tuple"))
          _        (.log.info* "Measuring writes")
          [n.nano
           _]      (.time.do*
                     (loop [i.iter 0]
                       (when (< i.iter
                                n.iter)
                         (.db.write (tuple n.long
                                           i.iter))
                         (recur (inc i.iter)))))]
      {:n.iter   n.iter
       :n.long   n.long
       :n.nano   n.nano
       :overhead (* n.iter
                    overhead)})))
