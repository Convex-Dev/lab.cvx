{:deploy [$.client.pool (lib client pool)
          $.peer        (lib peer)]}


;;;;;;;;;


(defn code.account+

  [n seed]

  (loop [acc []
         i   0]
    (if (< i
           n)
      (recur (conj acc
                   `(transfer (deploy '(set-key ~(.kp.pubkey (.kp.create (.gen (.gen.blob-32)
                                                                               {:seed (+ seed
                                                                                         i)})))))
                              100000000))
             (inc i))
      (cons 'do
            acc))))



(defn trx.account+

  [peer+ n]

  (when-not (.db.path)
    (.db.open (.fs.tmp)))
  (.try.resrc* [client (.client.connect)
                       (.client.close client)]
    (loop [seq         (.a.take (.client.sequence client
                                                  #11))
           n.remaining n]
      (when (> n.remaining
               0)
        (let [n.create (min n.remaining
                            250)]
          (.log.info* (str "Creating " n.create " accounts"))
          (let [result (.a.take
                         (.client.transact client
                                           (:kp (first peer+))
                                           (.trx.new.invoke #12
                                                            (code.account+ n.create
                                                                           (+ 45
                                                                              (- n
                                                                                 n.remaining)
                                                                              (dec (count peer+))))
                                                                              {:sequence seq}))
                         10000
                         :timeout)]
            (when (or (= result
                         :timeout)
                      (:error result))
              (.log.fatal* [:account-creation result])
              (fail :SETUP
                    "Unable to create accounts")))
          (recur (inc seq)
                 (- n.remaining
                    n.create)))))))
 


(defn load

  [peer+ n.peer n.account n.client]

  (let [client-pool ($.client.pool/connect.range n.client
                                                 n.peer)]
    (loop [acc []
           i   0]
      (if (< i
             n.account)
        (recur (conj acc
                     (.a.do*
                       (let [addr.long (+ 45
                                          (dec (count peer+))
                                          i)
                             addr      (address addr.long)
                             client    (nth client-pool
                                            (mod i
                                                 (count client-pool)))
                             kp        (.kp.create (.gen (.gen.blob-32)
                                                         {:seed addr.long}))]
                         (loop [i 1]
                           (let [trx      (.kp.sign kp
                                                    (.trx.new.invoke addr
                                                                     `(def foo
                                                                           ~(.gen (.gen.long)))
                                                                     {:sequence i}))
                                 [rtt
                                  result] (.time.do*
                                            (.a.take (.client.transact client
                                                                       trx)))]
                             (.log.report* [addr (/ rtt 1e6) result])
                             ;(.time.sleep (.gen (.gen.long.uniform 0
                             ;                                      50)))
                             (recur
                               (if (= (:error result)
                                      :SEQUENCE)
                                 (.a.take (.client.sequence client
                                                            addr))
                                 (inc i))))))))
               (inc i))
        acc))))





;;;;;;;;;;


(defn kp.seed+

  [n.peer]

  (let [controller.genesis 12]
    (loop [acc    []
           i.peer 0]
      (if (< i.peer
             n.peer)
        (recur (conj acc
                     (.gen (.gen.blob-32)
                           {:seed (+ controller.genesis
                                     i.peer)}))
               (inc i.peer))
        acc))))



(defn start-worker

  [name i.peer stream.out.limit]

  (.log.info* "Peer ready to operate")
  (.stream.outln :ready)
  (let [pipe (str name "_" i.peer)]
    (.log.info* (str "Starting worker named '" pipe "'"))
    (.worker.start {:pipe             pipe
                    :stream.out.limit stream.out.limit})))


(defn process.ensure-ready

  [process i.peer]

  (.log.info* (str "Awaiting peer " i.peer))
  (let [cell+ (.stream.line (:out process))
        error (cond
                ;;
                (empty? cell+)
                (str "Peer " i.peer " stopped before being ready, check logs")
                ;;
                (not (= cell+
                        '(:ready)))
                (str "Peer " i.peer " did not send the approriate signal indicating readiness"))]
    (when error
      (fail :SHELL.PEER
            error)))
  (.log.info* (str "Peer " i.peer " ready to operate"))
  process)



(defn monitor-exit

  [process i.peer]

  (.a.do*
       (let [code (.a.take (:exit process))]
         (if (zero? code)
           (.log.info* (str "Peer " i.peer " stopped normally"))
           (.log.error* (str "Peer " i.peer " stopped with non-zero exit code: " code)))))
  process)






(defn process

  [command config sym.fn]

  (let [i.peer   (:i.peer config)
        dir.peer (str (:dir config) "/" i.peer)
        peer     (.process.run
                   (conj command
                         (.cell.str
                           `(let [$.net.local (get (.dep.deploy '[$.net.local (lib net local)])
                                                   '$.net.local)]
                              ((lookup $.net.local
                                       ~sym.fn)
                               ~(assoc config
                                       :dir
                                       dir.peer)))))
                   {:err (.file.stream.out (str dir.peer "/err.txt"))})]
    (monitor-exit peer
                  (:i.peer config))
    peer))

            



(defn start


  ;; TODO. Allow preparing genesis state.
  ;;       Simplify providing pubkey for genesis peer.
  ;;       Allow resuming networks.


  ([name n.peer]

   (start name
          n.peer
          nil))


  ([name n.peer option+]

   (when (< n.peer
            1)
     (fail :ARGUMENT
           "Must run at least 1 peer"))
   (.log.info* (str "Starting local network '" name "'"))
   (.log.info* (str "N peers = " n.peer))
   (let [command            (vec (or (:command option+)
                                     '[cvx]))
         dir                ($.peer/dir option+)
         log.level          (or (:log.level option+)
                                :info)
         port.genesis       (or (:port.genesis option+)
                                .peer.default.port)
         config             {:dir              dir
                             :kp.seed+         (kp.seed+ n.peer)
                             :name             name
                             :log.level        (or (:log.level option+)
                                                   :info)
                             :port.genesis     port.genesis
                             :stream.out.limit (:stream.out.limit option+)}
         _                  (.log.info* "Starting peer 0 (genesis peer)")
         peer.genesis       (process command
                                     (assoc config
                                            :i.peer
                                            0)
                                     'start.genesis)]
     (process.ensure-ready peer.genesis
                           0)
     (let [n.peer.syncer (dec n.peer)]
       (when (> n.peer.syncer
                0)
         (.log.info* (str "Starting syncer peers"))
         (.log.info* (str "N syncers = " n.peer.syncer))
         (loop [peer.syncer+ []]
           (if (< (count peer.syncer+)
                         n.peer.syncer)
             (recur (conj peer.syncer+
                          (let [i.peer (inc (count peer.syncer+))]
                            (process command
                                     (assoc config
                                            :i.peer
                                            i.peer)
                                     'start.syncer))))
             {:name         name
              :peer+        (reduce (fn [peer+ peer.syncer]
                                      (process.ensure-ready peer.syncer
                                                            (count peer+))
                                      (conj peer+
                                             peer.syncer))
                                    [peer.genesis]
                                    peer.syncer+)
              :port.genesis port.genesis})))))))




(defn start.genesis

  [config]

  (let [kp.seed+     (:kp.seed+ config)
        n.peer       (count kp.seed+)
        port.genesis (:port.genesis config)]
    (.log.level.set (:log.level config))
    (def peer
         (:peer ($.peer/start (first kp.seed+)
                              (.state.genesis {:peer+
                                               (loop [acc    []
                                                      i.peer 0]
                                                 (if (< i.peer
                                                        n.peer)
                                                   (recur (conj acc
                                                                {:key  (.kp.pubkey (.kp.create (get kp.seed+
                                                                                                    i.peer)))
                                                                 :port (+ port.genesis
                                                                          i.peer)})
                                                          (inc i.peer))
                                                   acc))})
                              {:dir  (:dir config)
                               :port port.genesis})))
    (start-worker (:name config)
                  0
                  (:stream.out.limit config))))



(defn start.syncer

  [config]

  (.log.level.set (:log.level config))
  (let [i.peer       (:i.peer config)
        port.genesis (:port.genesis config)]
    (def peer
         (:peer ($.peer/start.sync (get (:kp.seed+ config)
                                        i.peer)
                                   {:dir  (:dir config)
                                    :port (+ port.genesis
                                             i.peer)})))
    (start-worker (:name config)
                  i.peer
                  (:stream.out.limit config))))



(defn repl.client


  ([net addr]

    (repl.client net
                 addr
                 nil))


  ([net addr option+]

   (.client.repl (merge {:key-pair (.kp.create (.gen (.gen.blob-32)
                                               {:seed (long addr)}))
                         :rtt?     true}
                        option+
                        {:address addr
                         :host     "localhost"
                         :port     (+ (:port.genesis net)
                                      (.gen (.gen.long.uniform 0
                                                               (dec (count (:peer+ net))))
                                            {:seed (.time.unix)}))}))))


(defn repl.peer


  ([net]

   (repl.peer net
              nil))


  ([net i.peer]

   (.worker.repl {:pipe (str (:name net)
                             "_" 
                             (or i.peer
                                 (.gen (.gen.long.uniform 0
                                                          (dec (count (:peer+ net))))
                                       {:seed (.time.unix)})))})))



(defn kill


  ([net]

   (kill net
         nil))


  ([net i.peer]

   (let [peer+ (:peer+ net)
         kill- (fn [i.peer]
                 (.log.info* (str "Killing peer " i.peer))
                 (.process.kill (get peer+
                                     i.peer)))]
     (if (nil? i.peer)
       (let [n.peer (count peer+)]
         (loop [i.peer-2 0]
           (when (< i.peer-2
                    n.peer)
             (kill- i.peer-2)
             (recur (inc i.peer-2)))))
       (kill- i.peer)))
   nil))



(defn stop


  ([net]

   (stop net
         nil))


  ([net i.peer]

   (let [peer+ (:peer+ net)
         stop- (fn [i.peer]
                 (.log.info* (str "Initiate clean shutdown of peer " i.peer))
                 (let [[in
                        out] (.worker.pipe+ (str (:name net) "_" i.peer))]
                   (.try.resrc* [in-2  (.file.stream.out in)
                                       (.stream.close in-2)
                                 out-2 (.file.stream.in out)
                                       (.stream.close out-2)]
                     (let [[ok?
                            _key
                            _result] (.worker.exec {:in  in-2
                                                    :out out-2}
                                                   '(do
                                                      (.log.info* "Attempting clean shutdown")
                                                      (.peer.stop peer)
                                                      (.log.info* "Peer stopped")
                                                      :worker.stop))]
                       (when-not ok?
                         (.log.error* (str "Error while trying to cleanly shutdown peer " i.peer)))))))]
     (if (nil? i.peer)
       (let [n.peer (count peer+)]
         (loop [i.peer-2 0]
           (when (< i.peer-2
                    n.peer)
             (stop- i.peer-2)
             (recur (inc i.peer-2)))))
       (stop- i.peer)))
   nil))
