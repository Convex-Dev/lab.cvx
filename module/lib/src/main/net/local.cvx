{:deploy [$.client.pool (lib client pool)
          $.peer        (lib peer)]}


;;;;;;;;;


(defn code.account+

  [n seed]

  (loop [acc []
         i   0]
    (if (< i
           n)
      (recur (conj acc
                   `(transfer (deploy '(set-key ~(.kp.pubkey (.kp.create (.gen (.gen.blob-32)
                                                                               {:seed (+ seed
                                                                                         i)})))))
                              100000000))
             (inc i))
      (cons 'do
            acc))))



(defn trx.account+

  [peer+ n]

  (when-not (.db.path)
    (.db.open (.fs.tmp)))
  (.try.resrc* [client (.client.connect)
                       (.client.close client)]
    (loop [seq         (.a.take (.client.sequence client
                                                  #11))
           n.remaining n]
      (when (> n.remaining
               0)
        (let [n.create (min n.remaining
                            250)]
          (.log.info* (str "Creating " n.create " accounts"))
          (let [result (.a.take
                         (.client.transact client
                                           (:kp (first peer+))
                                           (.trx.new.invoke #12
                                                            (code.account+ n.create
                                                                           (+ 45
                                                                              (- n
                                                                                 n.remaining)
                                                                              (dec (count peer+))))
                                                                              {:sequence seq}))
                         10000
                         :timeout)]
            (when (or (= result
                         :timeout)
                      (:error result))
              (.log.fatal* [:account-creation result])
              (fail :SETUP
                    "Unable to create accounts")))
          (recur (inc seq)
                 (- n.remaining
                    n.create)))))))
 


(defn load

  [peer+ n.peer n.account n.client]

  (let [client-pool ($.client.pool/connect.range n.client
                                                 n.peer)]
    (loop [acc []
           i   0]
      (if (< i
             n.account)
        (recur (conj acc
                     (.a.do*
                       (let [addr.long (+ 45
                                          (dec (count peer+))
                                          i)
                             addr      (address addr.long)
                             client    (nth client-pool
                                            (mod i
                                                 (count client-pool)))
                             kp        (.kp.create (.gen (.gen.blob-32)
                                                         {:seed addr.long}))]
                         (loop [i 1]
                           (let [trx      (.kp.sign kp
                                                    (.trx.new.invoke addr
                                                                     `(def foo
                                                                           ~(.gen (.gen.long)))
                                                                     {:sequence i}))
                                 [rtt
                                  result] (.time.do*
                                            (.a.take (.client.transact client
                                                                       trx)))]
                             (.log.report* [addr (/ rtt 1e6) result])
                             ;(.time.sleep (.gen (.gen.long.uniform 0
                             ;                                      50)))
                             (recur
                               (if (= (:error result)
                                      :SEQUENCE)
                                 (.a.take (.client.sequence client
                                                            addr))
                                 (inc i))))))))
               (inc i))
        acc))))





;;;;;;;;;;


(defn kp.seed

  [i.peer]

  (let [controller.genesis 12]
    (.gen (.gen.blob-32)
          {:seed (+ controller.genesis
                    i.peer)})))



(defn kp.seed+

  [n.peer]

  (let [controller.genesis 12]
    (loop [acc    []
           i.peer 0]
      (if (< i.peer
             n.peer)
        (recur (conj acc
                     (kp.seed i.peer))
               (inc i.peer))
        acc))))



(defn state.genesis.option+

  ([option+]

   (let [peer+        (:peer+ option+)
         n.peer       (or (:n.peer option+)
                          (count peer+))
         kp.seed+     (kp.seed+ n.peer)
         port.genesis (or (:port.genesis option+)
                          .peer.default.port)]
     (loop [acc    []
            i.peer 0]
       (if (< i.peer
              n.peer)
         (recur (conj acc
                      (merge (get peer+
                                  i.peer)
                             {:key  (.kp.pubkey (.kp.create (get kp.seed+
                                                                 i.peer)))
                              :port (+ port.genesis
                                       i.peer)}))
                (inc i.peer))
         {:peer+ acc})))))






(defn etch.extract

  [command path]

  (let [result  (.stream.in+
                          (:out
                            (.process.run
                              (conj command
                                    `(do
                                       (.db.open ~path)
                                       (.state.switch #12
                                                      (.db.root.read))
                                       (let [peer+ (:peers *state*)]
                                         [(count peer+)
                                          (get-in peer+
                                                  [(:key (account *address*))
                                                   :metadata
                                                   :url])]))))))
       _ (when (empty? result)
           (fail :SHELL.PEER
                 "Unable to extract information about peers from Etch"))
       [n.peer
       url.genesis] (first result)]
    (when-not (str? url.genesis)
      (fail :SHELL.PEER
            "Genesis URL missing"))
    [n.peer
     (first (.reader.form+ (second (split url.genesis
                                          \:))))]))



(defn etch


  ([path]

   (etch path
         nil))


  ([path option+]

   (.log.info* (str "Generating genesis Etch instance at '" (.fs.resolve path) "'"))
   (.process.success?
     (.process.run
       (concat (vec (or (:command option+)
                        ['cvx]))
               `[(.db.open ~path)
                 (let [prepare ~(:prepare option+)
                       state   (.state.genesis ~(state.genesis.option+ option+))]
                   (.db.root.write
                     (if prepare
                       (.state.core.vanilla (prepare state))
                       state)))
                 nil])))
   path))



(defn start-worker

  [name i.peer stream.out.limit]

  (.log.info* "Peer ready to operate")
  (.stream.outln :ready)
  (let [pipe (str name "_" i.peer)]
    (.log.info* (str "Starting worker named '" pipe "'"))
    (.worker.start {:pipe             pipe
                    :stream.out.limit stream.out.limit}))
  nil)



(defn process.ensure-ready

  [process i.peer]

  (.log.info* (str "Awaiting peer " i.peer))
  (let [cell+ (.stream.line (:out process))
        error (cond
                ;;
                (empty? cell+)
                (str "Peer " i.peer " stopped before being ready, check logs")
                ;;
                (not (= cell+
                        '(:ready)))
                (str "Peer " i.peer " did not send the approriate signal indicating readiness"))]
    (when error
      (fail :SHELL.PEER
            error)))
  (.log.info* (str "Peer " i.peer " ready to operate"))
  process)



(defn monitor-exit

  [process i.peer]

  (.a.do*
       (let [code (.a.take (:exit process))]
         (if (zero? code)
           (.log.info* (str "Peer " i.peer " stopped normally"))
           (.log.error* (str "Peer " i.peer " stopped with non-zero exit code: " code)))))
  process)






(defn process.start

  [command config sym.fn]

  (let [i.peer   (:i.peer config)
        dir.peer (str (:dir config) "/" i.peer)
        peer     (.process.run
                   (conj command
                         `(let [$.net.local (get (.dep.deploy '[$.net.local (lib net local)])
                                                 '$.net.local)]
                            ((lookup $.net.local
                                     ~sym.fn)
                             ~(assoc config
                                     :dir
                                     dir.peer))))
                   {:err (.file.stream.out (str dir.peer "/err.txt"))})]
    (monitor-exit peer
                  i.peer)
    peer))



(defn process.resume

  [command config]

  (let [i.peer   (:i.peer config)
        dir.peer (str (:dir config) "/" i.peer)
        peer     (.process.run
                   (conj command
                         `(let [dep+        (.dep.deploy '[$.net.local (lib net local)
                                                           $.peer      (lib peer)])
                                $.net.local (get dep+
                                                 '$.net.local)
                                $.peer      (get dep+
                                                 '$.peer)]
                                                 (.stream.errln [:log ~(:log.level config)])
                                                 (.stream.flush (.stream.stderr))
                            (.log.level.set ~(:log.level config))
                            ($.peer/resume ~(kp.seed i.peer)
                                           {:dir ~dir.peer})
                            ($.net.local/start-worker ~(:name config)
                                                      ~i.peer
                                                      ~(:stream.out.limit config))))
                   {:err (.file.stream.out (str dir.peer "/err.txt"))})]
    (monitor-exit peer
                  i.peer)
    peer))


            



(defn start


  ;; TODO. Allow preparing genesis state.
  ;;       Simplify providing pubkey for genesis peer.
  ;;       Allow resuming networks.


  ([name]

   (start name
          nil))


  ([name option+]

   (.log.info* (str "Starting local network '" name "'"))
   (let [command            (vec (or (:command option+)
                                     '[cvx]))
         dir                ($.peer/dir option+)
         log.level          (or (:log.level option+)
                                :info)
         state              (:state option+)
         [n.peer
          port.genesis
          etch.origin]     (if (str? state)
                              (do
                                (.log.info* (str "Reusing genesis Etch instance at '" state "'"))
                                (conj (etch.extract command
                                                    state)
                                      state))
                              (let [path (str dir "/genesis.etch")]
                                (when-not (etch path
                                                (assoc option+
                                                       :n.peer       3
                                                       :port.genesis 18888))
                                  (fail :SHELL.PEER
                                        "Error while generating genesis Etch instance"))
                                [3
                                 18888
                                 path]))
         _                  (do
                              (.log.info* (str "N peers = " n.peer))
                              (.log.info* (str "Genesis port = " port.genesis)))
         config             {:dir              dir
                             :etch.origin      etch.origin
                             :kp.seed+         (kp.seed+ n.peer)
                             :n.max.sibling    (:n.max.sibling option+)
                             :name             name
                             :log.level        (or (:log.level option+)
                                                   :info)
                             :poll-delay       (:poll-delay option+)
                             :port.genesis     port.genesis
                             :stream.out.limit (:stream.out.limit option+)}
         _                  (.log.info* "Starting peer 0 (genesis peer)")
         peer.genesis       (process.start command
                                           (assoc config
                                                  :i.peer
                                                  0)
                                           'start.genesis)]
     (process.ensure-ready peer.genesis
                           0)
     (let [config-2      (if (= (:etch.origin.syncer? option+)
                                false)
                           (do
                             (.log.info* "Etch genesis instance will NOT be copied by syncer peers")
                             (dissoc config
                                     :etch.origin))
                           (do
                             (.log.info* "Etch genesis instance will be copied by syncer peers")
                             config))
           n.peer.syncer (dec n.peer)]
       (when (> n.peer.syncer
                0)
         (.log.info* (str "Starting syncer peers"))
         (.log.info* (str "N syncers = " n.peer.syncer))
         (loop [peer.syncer+ []]
           (if (< (count peer.syncer+)
                         n.peer.syncer)
             (recur (conj peer.syncer+
                          (let [i.peer (inc (count peer.syncer+))]
                            (process.start command
                                           (assoc config-2
                                                  :i.peer
                                                  i.peer)
                                           'start.syncer))))
             {:name         name
              :peer+        (reduce (fn [peer+ peer.syncer]
                                      (process.ensure-ready peer.syncer
                                                            (count peer+))
                                      (conj peer+
                                            peer.syncer))
                                    [peer.genesis]
                                    peer.syncer+)
              :port.genesis port.genesis})))))))



(defn start.genesis

  [config]

  (.log.level.set (:log.level config))
  (def peer
       (:peer ($.peer/start (first (:kp.seed+ config))
                            (assoc (dissoc config
                                           :etch.origin)
                                   :state
                                   (:etch.origin config)))))
  (start-worker (:name config)
                0
                (:stream.out.limit config)))



(defn start.syncer

  [config]

  (.log.level.set (:log.level config))
  (let [i.peer       (:i.peer config)
        port.genesis (:port.genesis config)]
    (def peer
         (:peer ($.peer/start.sync (get (:kp.seed+ config)
                                        i.peer)
                                   (assoc config
                                          :port
                                          (+ port.genesis
                                             i.peer)))))
    (start-worker (:name config)
                  i.peer
                  (:stream.out.limit config))))



(defn repl.client


  ([net addr]

    (repl.client net
                 addr
                 nil))


  ([net addr option+]

   (.client.repl (merge {:key-pair (.kp.create (.gen (.gen.blob-32)
                                               {:seed (long addr)}))
                         :rtt?     true}
                        option+
                        {:address addr
                         :host     "localhost"
                         :port     (+ (:port.genesis net)
                                      (.gen (.gen.long.uniform 0
                                                               (dec (count (:peer+ net))))
                                            {:seed (.time.unix)}))}))))


(defn repl.peer


  ([net]

   (repl.peer net
              nil))


  ([net i.peer]

   (.worker.repl {:pipe (str (:name net)
                             "_" 
                             (or i.peer
                                 (.gen (.gen.long.uniform 0
                                                          (dec (count (:peer+ net))))
                                       {:seed (.time.unix)})))})))



(defn kill


  ([net]

   (kill net
         nil))


  ([net i.peer]

   (let [peer+ (:peer+ net)
         kill- (fn [i.peer]
                 (.log.info* (str "Killing peer " i.peer))
                 (.process.kill (get peer+
                                     i.peer)))]
     (if (nil? i.peer)
       (let [n.peer (count peer+)]
         (loop [i.peer-2 0]
           (when (< i.peer-2
                    n.peer)
             (kill- i.peer-2)
             (recur (inc i.peer-2)))))
       (kill- i.peer)))
   nil))



(defn stop


  ([net]

   (stop net
         nil))


  ([net i.peer]

   (let [peer+ (:peer+ net)
         stop- (fn [i.peer]
                 (.log.info* (str "Initiate clean shutdown of peer " i.peer))
                 (let [[in
                        out] (.worker.pipe+ (str (:name net) "_" i.peer))]
                   (.try.resrc* [in-2  (.file.stream.out in)
                                       (.stream.close in-2)
                                 out-2 (.file.stream.in out)
                                       (.stream.close out-2)]
                     (let [[ok?
                            _key
                            _result] (.worker.exec {:in  in-2
                                                    :out out-2}
                                                   '(do
                                                      (.log.info* "Attempting clean shutdown")
                                                      (.peer.stop peer)
                                                      (.log.info* "Peer stopped")
                                                      :worker.stop))]
                       (when-not ok?
                         (.log.error* (str "Error while trying to cleanly shutdown peer " i.peer)))))))]
     (if (nil? i.peer)
       (let [n.peer (count peer+)]
         (loop [i.peer-2 0]
           (when (< i.peer-2
                    n.peer)
             (stop- i.peer-2)
             (recur (inc i.peer-2)))))
       (stop- i.peer)))
   nil))




(defn resume

  
  ([name]

   (resume name
           nil))


  ([name option+]

   (.log.info* (str "Resuming local network '" name "'"))
   (let [command      (vec (or (:command option+)
                                '[cvx]))
         dir          ($.peer/dir option+)
         config       {:dir              dir
                       :log.level        (or (:log.level option+)
                                             :info)
                       :name             name
                       :stream.out.limit (:stream.out.limit option+)}
         _            (.log.info* "Resuming peer 0 (genesis peer)")
         peer.genesis (process.resume command
                                      (assoc config
                                             :i.peer
                                             0))]
     (process.ensure-ready peer.genesis
                           0)
     (loop [peer.syncer+ []]
       (let [i.peer (inc (count peer.syncer+))]
         (if (.fs.exists? (str dir "/" i.peer))
           (recur (conj peer.syncer+
                        (process.resume command
                                        (assoc config
                                               :i.peer
                                               i.peer))))
           {:name         name
            :peer+        (reduce (fn [peer+ peer.syncer]
                                    (process.ensure-ready peer.syncer
                                                          (count peer+))
                                    (conj peer+
                                          peer.syncer))
                                  [peer.genesis]
                                  peer.syncer+)
            :port.genesis (:port (first (.file.read (str dir "/0/config.cvx"))))}))))))
