{:deploy [$.client.pool (lib client pool)]}


;;;;;;;;;


(defn kp.create+

  [n]

  (loop [acc []
         i   0]
    (if (< i
           n)
      (recur (conj acc
                   (.kp.create))
             (inc i))
      acc)))



(defn init.syncer

  [command dir i kp+]

  [i
   (.a.do*
     (let [port  (+ 18888
                    i)
           peer  (peer.process command
                               dir
                               i
                               (nth kp+
                                    i))
           [ok?
            _key
            x]   (.worker.exec peer
                               `(do
                                  (.log.info* "Initializing peer")
                                  (let [[ok?
                                         x]  (.state.safe*
                                               (def peer
                                                    (.peer.init.sync kp
                                                                     {
                                                                        :delay.poll 1000000000

                                                                      :port        ~port
                                                                      :remote.port 18888})))]
                                    (when-not ok?
                                      (.log.fatal* ["Exception while initializing and syncing peer"
                                                    x])
                                      (.sys.exit 132))
                                    (.log.info* "Starting peer and accepting client connections")
                                    (let [[ok?
                                           x]  (.state.safe*
                                                 (.peer.start peer))]
                                      (when-not ok?
                                        (.log.fatal* ["Exception while starting peer"
                                                      x])
                                        (.sys.exit 133))
                                        true))))]
       (if ok?
         peer
         (fail :PEER
               (str "Syncing peer " i " failed initialization")))))])
              




(defn peer.process

  [command dir i kp]

  (.log.info* (str "Initializing process for Peer " i))
  (let [seed (.kp.seed kp)
        peer (.process.run (conj command
                                 `(let [[ok?
                                         x]  (.state.safe*
                                               (.log.level.set :debug)
                                               (.log.out.set (.file.stream.out ~(str dir "/" i "/log.cvx"))))]
                                    (when-not ok?
                                      (.sys.exit 128))
                                    (let [[ok?
                                           x]  (.state.safe*
                                                 (let [etch ~(.fs.resolve (str dir "/" i "/store.etch"))]
                                                   (.log.info* (str "Opening Etch: " etch))
                                                   (.db.open etch)))]
                                     (when-not ok?
                                       (.log.fatal* ["Exception while opening Etch"
                                                     x])
                                       (.sys.exit 129))
                                     (let [[ok?
                                            x]  (.state.safe*
                                                  (.log.info* ~(str "Recreating key pair under `kp` from seed: " seed))
                                                  (def kp
                                                       (.kp.create ~seed)))]
                                       (when-not ok?
                                         (.log.fatal* ["Exception while recreating key pair"
                                                       x])
                                         (.sys.exit 130))
                                       (.stream.outln true)
                                       (.worker.start {:stream.out.limit nil}))))))]
    (.a.do*
      (let [exit-code (.a.take (:exit peer))]
        (if (zero? exit-code)
          (.log.info* (str "Peer " i " terminated normally"))
          (.log.error* (str "Peer " i " terminated abnormally with exit code: " exit-code)))))
    (if (= (.stream.line (:out peer))
           '(true))
      (assoc peer
             :i  i
             :kp kp)
      (fail :PEER
            (str "Peer " i " failed while preparing process")))))







(defn init.genesis

  [command dir kp+]

  (let [n.peer  (count kp+)
        kp      (first kp+)
        peer    (peer.process command
                              dir
                              0
                              kp)
        stake+  (.gen (.gen.vector (.gen.long.uniform 5000000000000000
                                                      30000000000000000)
                                   10))
        [ok?
         _key
         x]     (.worker.exec peer
                              `(let [[ok?
                                      x]  (.state.safe*
                                            (.log.info* ~(str "Generating genesis state for " n.peer " peer(s)"))
                                            (.state.genesis {:each-peer '(fn [peer]
                                                                           (let [controller (:controller peer)]
                                                                             (.log.info* (str "Preparing URL for peer controlled by "
                                                                                              controller))

                                                                             ;(set-peer-stake (:key peer) 13019880000000000)
                                                                             ;(set-peer-stake (:key peer) 100000000)
                                                                             ;(set-peer-stake (:key peer) 1000000000)
                                                                             ;(set-peer-stake (:key peer) 10000)
                                                                             ;(set-peer-stake (:key peer) 100000)
                                                                             #_(set-peer-stake (:key peer)
                                                                                             (.gen (.gen.long.uniform 5000000000000000
                                                                                                                      30000000000000000)))
                                                                             #_(set-peer-stake (:key peer)
                                                                                             (nth ~stake+
                                                                                                  (- (long controller)
                                                                                                     12)))


                                                                             (set-peer-data (:key peer)
                                                                                            {:url (str "localhost:"
                                                                                                       (+ 18888
                                                                                                          (long controller)
                                                                                                          -12))})))
                                                              :pubkey+  ~(map .kp.pubkey
                                                                              kp+)}))]
                                 (when-not ok?
                                   (.log.fatal* ["Exception while generating genesis state"
                                                 x])
                                   (.sys.exit 131))
                                 (.log.info* ["Genesis peers"
                                              (:peers x)])
                                 (.log.info* "Initializing peer")
                                 (let [[ok?
                                        x]  (.state.safe*
                                              (def peer
                                                   (.peer.init kp
                                                               {:delay.poll 1000000000


                                                                :state      x})))]
                                   (when-not ok?
                                     (.log.fatal* ["Exception while initializing peer"
                                                   x])
                                     (.sys.exit 132))
                                   (.log.info* "Starting peer and accepting client connections")
                                   (let [[ok?
                                          x]  (.peer.start peer)]
                                     (when-not ok?
                                       (.log.fatal* ["Exception while starting peer"
                                                     x])
                                       (.sys.exit 133))
                                     true))))]
    (if ok?
      peer
      (fail :PEER
            (str "Genesis peer failed initialization")))))




(defn start


  ([command]

   (start command
          nil))


  ([command option+]

   (let [dir   (.fs.resolve (or (:dir option+)
                                "./"))
         n     (or (:n option+)
                   (.sys.n-cpu))
         _     (when-not (and (long? n)
                              (>= n
                                  1))
                 (fail :ARGUMENT
                       "Number of peers must be >= 1"))
         kp+   (kp.create+ n)
         peer.genesis (init.genesis command
                                    dir
                                    kp+)
         ]
     (loop [acc []
            i   1]
       (if (< i
              n)
         (recur (conj acc
                      (init.syncer command
                                   dir
                                   i
                                   kp+))
                (inc i))
         (cons peer.genesis
               (map (fn [[i d*peer]]
                      (.log.info* (str "Awaiting Peer " i)) 
                      (.a.take d*peer))
                    acc)))))))



(defn stop

  [peer+]

  (let [n (count peer+)]
    (loop [i 0]
      (when (< i
               n)
        (.log.info* (str "Killing Peer "
                         i))
        (.process.kill (nth peer+
                            i))
        (recur (inc i)))))
  nil)



(defn repl

  [peer+ i]

  (.worker.repl (nth peer+
                     i)
                {:name (str "peer-" i)}))
                            





(defn client.repl


  ([peer+ i]

   (client.repl peer+
                i
                nil))


  ([peer+ i option+]

   (.client.repl (merge {:rtt? true}
                        option+
                        {:address  (address (+ (long .account.genesis)
                                               1
                                               i))
                         :host     "localhost"
                         :key-pair (:kp (nth peer+
                                             i))
                         :port     (+ 18888
                                      i)}))))


(defn go

  [n]

  (.log.level.set :info)
  (def ps
       (start '[java "-Xms2G" "-jar" "/Users/adam/Code/convex/clj/tool/private/target/shell.uber.jar"]
              ;'[cvx]
              {:dir "/tmp/net"
               :n   n})))




(defn code.account+

  [n seed]

  (loop [acc []
         i   0]
    (if (< i
           n)
      (recur (conj acc
                   `(transfer (deploy '(set-key ~(.kp.pubkey (.kp.create (.gen (.gen.blob-32)
                                                                               {:seed (+ seed
                                                                                         i)})))))
                              100000000))
             (inc i))
      (cons 'do
            acc))))



(defn trx.account+

  [n]

  (when-not (.db.path)
    (.db.open (.fs.tmp)))
  (.try.resrc* [client (.client.connect)
                       (.client.close client)]
    (.a.take (.client.transact client
                               (:kp (first ps))
                               (.trx.new.invoke #11
                                                (code.account+ n
                                                               (+ 45
                                                                  (dec (count ps))))
                                                {:sequence (.a.take (.client.sequence client
                                                                                      #11))}))

             10000
             :timeout)))
 


(defn load

  [n]

  (let [client-pool ($.client.pool/connect.range 200
                                                 10)]
    (loop [acc []
           i   0]
      (if (< i
             n)
        (recur (conj acc
                     (.a.do*
                       (let [addr.long (+ 45
                                          (dec (count ps))
                                          i)
                             addr      (address addr.long)
                             client    (nth client-pool
                                            (mod i
                                                 (count client-pool)))
                             kp        (.kp.create (.gen (.gen.blob-32)
                                                         {:seed addr.long}))]
                         (loop [i 1]
                           (let [trx      (.kp.sign kp
                                                    (.trx.new.invoke addr
                                                                     `(def foo
                                                                           ~(.gen (.gen.long)))
                                                                     {:sequence i}))
                                 [rtt
                                  result] (.time.do*
                                            (.a.take (.client.transact client
                                                                       trx)))]
                             (.log.report* [addr (/ rtt 1e6) result])
                             ;(.time.sleep (.gen (.gen.long.uniform 0
                             ;                                      50)))
                             (recur (inc i)))))))
               (inc i))
        acc))))



(defn status+

  [peer+]

  (let [n (count peer+)]
    (loop [acc []
           i   0]
      (if (< i
             n)
        (recur (conj acc
                     (let [[ok?
                            _key
                            status] (.worker.exec (nth peer+
                                                       i)
                                                  '(.peer.status peer))]
                       (when-not ok?
                         (fail :FAIL
                               (str "Unable to retrieve status for Peer " i)))
                       (assoc status
                              :i
                              i)))
               (inc i))
        acc))))
      


(defn pr.status+

  [peer+]

  (map (fn [status]
         (.stream.txt.out "Peer ")
         (.stream.outln (:i status))
         (.stream.txt.out "Proposal point: ")
         (.stream.outln (:point.proposal status))
         (.stream.txt.out "Consensus point: ")
         (.stream.outln (:point.consensus status))
         (.stream.txt.out "N blocks: ")
         (.stream.outln (:n.block status))
         (.stream.txt.out "Consensus state hash: ")
         (.stream.outln (:hash.state.consensus status))
         (.stream.txt.outln ""))
       (status+ peer+))
  nil)



(defn agreement

  [peer+]

  (let [n       (count peer+)
        status+ (status+ peer+)]
    (loop [acc {}
           i   0]
      (if (< i
             n)
        (recur (let [status               (nth status+
                                               i)
                     point.consensus      (:point.consensus status)
                     hash->i.peer+        (or (get acc
                                                   point.consensus)
                                              {})
                     hash.state.consensus (:hash.state.consensus status)]
                 (assoc acc
                        point.consensus
                        (assoc hash->i.peer+
                               hash.state.consensus
                               (conj (or (get hash->i.peer+
                                              hash.state.consensus)
                                         [])
                                     i))))
               (inc i))
        acc))))



(defn pr.agreement

  [peer+]

  (map (fn [[point.consensus hash.state.consensus->i.peer+]]
         (.stream.txt.outln (str "Consensus point: " point.consensus))
         (map (fn [[hash.state.consensus i.peer+]]
                (.stream.txt.outln (str hash.state.consensus " <- " i.peer+)))
              hash.state.consensus->i.peer+)
         (.stream.txt.outln ""))
       (agreement peer+))
  nil)



(defn block.hash+

  [peer+]

  (map (fn [peer]
         (let [[ok?
                _key
                result] (.worker.exec peer
                                      '(map (fn [block]
                                              (hash (encoding block)))
                                            (:blocks (.peer.order peer))))]
           (when-not ok?
             (fail :FAIL
                   (str "Unable to retrieve block hashes for Peer " (:i peer))))
           result))
       peer+))



(defn block.consistency

  [peer+]

  (let [hash+   (block.hash+ peer+)
        n.peer  (count hash+)
        status+ (status+ peer+)]
    (loop [acc    []
           i.peer 0]
      (if (< i.peer
             n.peer)
        (let [cp         (:point.consensus (nth status+
                                                i.peer))
              peer.hash+ (nth hash+
                              i.peer)]
          (recur (conj acc
                       (loop [acc-2    []
                              i.peer-2 0]
                         (cond
                           ;;
                           (= i.peer-2
                              i.peer)
                           (recur (conj acc-2
                                        1)
                                  (inc i.peer-2))
                           ;;
                           (< i.peer-2
                              n.peer)
                           (let [peer-2.hash+ (nth hash+
                                                   i.peer-2)
                                 n.block      (min cp
                                                   (:point.consensus (nth status+
                                                                          i.peer-2)))]
                             (recur (conj acc-2
                                          (loop [i.block  0]
                                            (if (< i.block
                                                   n.block)
                                              (if (= (nth peer.hash+
                                                          i.block)
                                                     (nth peer-2.hash+
                                                          i.block))
                                                (recur (inc i.block))
                                                (/ i.block
                                                   n.block))
                                              1)))
                                    (inc i.peer-2)))
                           ;;
                           acc-2)))
                 (inc i.peer)))
        acc))))



(defn pr.block.consistency

  [peer+]

  (map .stream.outln
       (block.consistency peer+))
  nil)



(defn divergence

  [peer+ i.peer-1 i.peer-2]

  (let [status+  (status+ peer+)
        cp       (min (:point.consensus (nth status+
                                             i.peer-1))
                      (:point.consensus (nth status+
                                             i.peer-2)))
        block+   (block.hash+ peer+)
        block-1+ (nth block+
                      i.peer-1)
        block-2+ (nth block+
                      i.peer-2)]
    (loop [i 0]
      (if (< i
             cp)
        (let [h (nth block-1+
                     i)]
          (if (= h
                 (nth block-2+
                      i))
            (recur (inc i))
            (let [last-block-1+ (slice block-1+
                                       i
                                       cp)
                  last-block-2+ (slice block-2+
                                       i
                                       cp)]
              [cp
               (count (difference (set last-block-1+)
                                  (set last-block-2+)))
               (reduce +
                       0
                       (map (fn [b-1 b-2]
                              (if (= b-1
                                     b-2)
                                1
                                0))
                            last-block-1+
                            last-block-2+))
               last-block-1+
               last-block-2+])))
        nil))))



(defn pr.divergence

  [peer+ i.peer-1 i.peer-2]

  (when-let [[cp.joint
              n.diff
              n.aligned
              last-block-1+
              last-block-2+] (divergence peer+
                                         i.peer-1
                                         i.peer-2)]
         (.stream.txt.outln "")
         (.stream.txt.outln (str "Joint consensus point: " cp.joint))
         (.stream.txt.outln (str "N blocks divergent until joint consensus point: " (count last-block-1+)))
         (.stream.txt.outln (str "N different blocks: " n.diff))
         (.stream.txt.outln (str "N blocks aligned within divergent portion: " n.aligned))
         (.stream.txt.outln "")
         (.stream.txt.outln (str "Peer " i.peer-1 " last blocks:"))
         (map (fn [h]
                (.stream.txt.outln (str "    " h)))
              last-block-1+)
         (.stream.txt.outln "")
         (.stream.txt.outln (str "Peer " i.peer-2 " last blocks:"))
         (map (fn [h]
                (.stream.txt.outln (str "    " h)))
              last-block-2+))
  nil)



(defn fake-convergence

  [peer+]

  (reduce (fn [acc [cp hash.state.consensus->i.peer+]]
            (reduce (fn [acc-2 [hash.state.consensus i.peer+]]
                      (loop [acc-3     acc-2
                             i.peer-2+ i.peer+]
                        (if (empty? i.peer-2+)
                          acc-3
                          (let [i.peer    (first i.peer-2+)
                                i.peer-3+ (next i.peer-2+)]
                            (recur (reduce (fn [acc-4 i.peer-2]
                                             (if-let [d (divergence peer+
                                                                    i.peer
                                                                    i.peer-2)]
                                               (conj acc-4
                                                     [i.peer
                                                      i.peer-2])
                                               acc-4))
                                           acc-3
                                           i.peer-3+)
                                   i.peer-3+)))))
                    acc
                    hash.state.consensus->i.peer+))
          []
          (agreement peer+)))
