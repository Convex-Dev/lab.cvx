{:deploy [$.client.pool (lib client pool)
          $.peer        (lib peer)]}


;;;;;;;;;


(defn kp.create+

  [n]

  (loop [acc []
         i   0]
    (if (< i
           n)
      (recur (conj acc
                   (.kp.create))
             (inc i))
      acc)))




              




(defn peer.process

  [command dir i kp]

  (.log.info* (str "Initializing process for Peer " i))
  (let [seed (.kp.seed kp)
        peer (.process.run (conj command
                                 `(let [[ok?
                                         x]  (.state.safe*
                                               (.log.level.set :info)
                                               (.log.out.set (.file.stream.out ~(str dir "/" i "/log.cvx"))))]
                                    (when-not ok?
                                      (.sys.exit 128))
                                    (let [[ok?
                                           x]  (.state.safe*
                                                 (let [etch ~(.fs.resolve (str dir "/" i "/store.etch"))]
                                                   (.log.info* (str "Opening Etch: " etch))
                                                   (.db.open etch)))]
                                     (when-not ok?
                                       (.log.fatal* ["Exception while opening Etch"
                                                     x])
                                       (.sys.exit 129))
                                     (let [[ok?
                                            x]  (.state.safe*
                                                  (.log.info* ~(str "Recreating key pair under `kp` from seed: " seed))
                                                  (def kp
                                                       (.kp.create ~seed)))]
                                       (when-not ok?
                                         (.log.fatal* ["Exception while recreating key pair"
                                                       x])
                                         (.sys.exit 130))
                                       (.stream.outln true)
                                       (.worker.start {:stream.out.limit nil}))))))]
    (.a.do*
      (let [exit-code (.a.take (:exit peer))]
        (if (zero? exit-code)
          (.log.info* (str "Peer " i " terminated normally"))
          (.log.error* (str "Peer " i " terminated abnormally with exit code: " exit-code)))))
    (if (= (.stream.line (:out peer))
           '(true))
      (assoc peer
             :i  i
             :kp kp)
      (fail :PEER
            (str "Peer " i " failed while preparing process")))))







(defn init.genesis

  [command dir kp+]

  (let [n.peer  (count kp+)
        kp      (first kp+)
        peer    (peer.process command
                              dir
                              0
                              kp)
        stake+  (.gen (.gen.vector (.gen.long.uniform 5000000000000000
                                                      30000000000000000)
                                   10))
        [ok?
         _key
         x]     (.worker.exec peer
                              `(let [[ok?
                                      x]  (.state.safe*
                                            (.log.info* ~(str "Generating genesis state for " n.peer " peer(s)"))
                                            (.state.genesis {:each-peer '(fn [peer]
                                                                           (let [controller (:controller peer)]
                                                                             (.log.info* (str "Preparing URL for peer controlled by "
                                                                                              controller))

                                                                             ;(set-peer-stake (:key peer) 13019880000000000)
                                                                             ;(set-peer-stake (:key peer) 100000000)
                                                                             ;(set-peer-stake (:key peer) 1000000000)
                                                                             ;(set-peer-stake (:key peer) 10000)
                                                                             ;(set-peer-stake (:key peer) 100000)
                                                                             #_(set-peer-stake (:key peer)
                                                                                             (.gen (.gen.long.uniform 5000000000000000
                                                                                                                      30000000000000000)))
                                                                             #_(set-peer-stake (:key peer)
                                                                                             (nth ~stake+
                                                                                                  (- (long controller)
                                                                                                     12)))


                                                                             (set-peer-data (:key peer)
                                                                                            {:url (str "localhost:"
                                                                                                       (+ 18888
                                                                                                          (long controller)
                                                                                                          -12))})))
                                                              :pubkey+  ~(map .kp.pubkey
                                                                              kp+)}))]
                                 (when-not ok?
                                   (.log.fatal* ["Exception while generating genesis state"
                                                 x])
                                   (.sys.exit 131))
                                 (.log.info* ["Genesis peers"
                                              (:peers x)])
                                 (.log.info* "Initializing peer")
                                 (let [[ok?
                                        x]  (.state.safe*
                                              (def peer
                                                   (.peer.init kp
                                                               {;:delay.poll 1000000000


                                                                :state      x})))]
                                   (when-not ok?
                                     (.log.fatal* ["Exception while initializing peer"
                                                   x])
                                     (.sys.exit 132))
                                   (.log.info* "Starting peer and accepting client connections")
                                   (let [[ok?
                                          x]  (.peer.start peer)]
                                     (when-not ok?
                                       (.log.fatal* ["Exception while starting peer"
                                                     x])
                                       (.sys.exit 133))
                                     true))))]
    (if ok?
      peer
      (fail :PEER
            (str "Genesis peer failed initialization")))))



(defn init.syncer

  [command dir i kp+]

  [i
   (.a.do*
     (let [port  (+ 18888
                    i)
           peer  (peer.process command
                               dir
                               i
                               (nth kp+
                                    i))
           [ok?
            _key
            x]   (.worker.exec peer
                               `(do
                                  (.log.info* "Initializing peer")
                                  (let [[ok?
                                         x]  (.state.safe*
                                               (def peer
                                                    (.peer.init.sync kp
                                                                     {
                                                                        ;:delay.poll 1000000000

                                                                      :port        ~port
                                                                      :remote.port 18888})))]
                                    (when-not ok?
                                      (.log.fatal* ["Exception while initializing and syncing peer"
                                                    x])
                                      (.sys.exit 132))
                                    (.log.info* "Starting peer and accepting client connections")
                                    (let [[ok?
                                           x]  (.state.safe*
                                                 (.peer.start peer))]
                                      (when-not ok?
                                        (.log.fatal* ["Exception while starting peer"
                                                      x])
                                        (.sys.exit 133))
                                        true))))]
       (if ok?
         peer
         (fail :PEER
               (str "Syncing peer " i " failed initialization")))))])





(defn start


  ([command]

   (start command
          nil))


  ([command option+]

   (let [dir   (.fs.resolve (or (:dir option+)
                                "./"))
         n     (or (:n option+)
                   (.sys.n-cpu))
         _     (when-not (and (long? n)
                              (>= n
                                  1))
                 (fail :ARGUMENT
                       "Number of peers must be >= 1"))
         kp+   (kp.create+ n)
         peer.genesis (init.genesis command
                                    dir
                                    kp+)
         ]
     (loop [acc []
            i   1]
       (if (< i
              n)
         (recur (conj acc
                      (init.syncer command
                                   dir
                                   i
                                   kp+))
                (inc i))
         (cons peer.genesis
               (map (fn [[i d*peer]]
                      (.log.info* (str "Awaiting Peer " i)) 
                      (.a.take d*peer))
                    acc)))))))



(defn stop

  [peer+]

  (let [n (count peer+)]
    (loop [i 0]
      (when (< i
               n)
        (.log.info* (str "Killing Peer "
                         i))
        (.process.kill (nth peer+
                            i))
        (recur (inc i)))))
  nil)



(defn repl

  [peer+ i]

  (.worker.repl (nth peer+
                     i)
                {:name (str "peer-" i)}))
                            





(defn client.repl


  ([peer+ i]

   (client.repl peer+
                i
                nil))


  ([peer+ i option+]

   (.client.repl (merge {:rtt? true}
                        option+
                        {:address  (address (+ (long .account.genesis)
                                               1
                                               i))
                         :host     "localhost"
                         :key-pair (:kp (nth peer+
                                             i))
                         :port     (+ 18888
                                      i)}))))


(defn go

  [n]

  (.log.level.set :info)
  (def ps
       (start ;'[java "-Xms10G" "-Xmx20G" "-jar" "/Users/adam/Code/convex/clj/tool/private/target/shell.uber.jar"]
              '[cvx]
              {:dir "/tmp/net"
               :n   n})))




(defn code.account+

  [n seed]

  (loop [acc []
         i   0]
    (if (< i
           n)
      (recur (conj acc
                   `(transfer (deploy '(set-key ~(.kp.pubkey (.kp.create (.gen (.gen.blob-32)
                                                                               {:seed (+ seed
                                                                                         i)})))))
                              100000000))
             (inc i))
      (cons 'do
            acc))))



(defn trx.account+

  [peer+ n]

  (when-not (.db.path)
    (.db.open (.fs.tmp)))
  (.try.resrc* [client (.client.connect)
                       (.client.close client)]
    (loop [seq         (.a.take (.client.sequence client
                                                  #11))
           n.remaining n]
      (when (> n.remaining
               0)
        (let [n.create (min n.remaining
                            250)]
          (.log.info* (str "Creating " n.create " accounts"))
          (let [result (.a.take
                         (.client.transact client
                                           (:kp (first peer+))
                                           (.trx.new.invoke #12
                                                            (code.account+ n.create
                                                                           (+ 45
                                                                              (- n
                                                                                 n.remaining)
                                                                              (dec (count peer+))))
                                                                              {:sequence seq}))
                         10000
                         :timeout)]
            (when (or (= result
                         :timeout)
                      (:error result))
              (.log.fatal* [:account-creation result])
              (fail :SETUP
                    "Unable to create accounts")))
          (recur (inc seq)
                 (- n.remaining
                    n.create)))))))
 


(defn load

  [peer+ n.peer n.account n.client]

  (let [client-pool ($.client.pool/connect.range n.client
                                                 n.peer)]
    (loop [acc []
           i   0]
      (if (< i
             n.account)
        (recur (conj acc
                     (.a.do*
                       (let [addr.long (+ 45
                                          (dec (count peer+))
                                          i)
                             addr      (address addr.long)
                             client    (nth client-pool
                                            (mod i
                                                 (count client-pool)))
                             kp        (.kp.create (.gen (.gen.blob-32)
                                                         {:seed addr.long}))]
                         (loop [i 1]
                           (let [trx      (.kp.sign kp
                                                    (.trx.new.invoke addr
                                                                     `(def foo
                                                                           ~(.gen (.gen.long)))
                                                                     {:sequence i}))
                                 [rtt
                                  result] (.time.do*
                                            (.a.take (.client.transact client
                                                                       trx)))]
                             (.log.report* [addr (/ rtt 1e6) result])
                             ;(.time.sleep (.gen (.gen.long.uniform 0
                             ;                                      50)))
                             (recur
                               (if (= (:error result)
                                      :SEQUENCE)
                                 (.a.take (.client.sequence client
                                                            addr))
                                 (inc i))))))))
               (inc i))
        acc))))



(defn main

  [n.peer n.client]

  (let [peer+ (go n.peer)]
    (trx.account+ peer+
                  n.client)
    (load peer+
          n.peer
          n.client
          n.client)))








(defn start


  ;; TODO. Allow preparing genesis state.
  ;;       Simplify providing pubkey for genesis peer.
  ;;       Allow resuming networks.


  ([name n.peer]

   (start name
          n.peer
          nil))


  ([name n.peer option+]

   (when (< n.peer
            1)
     (fail :ARGUMENT
           "Must run at least 1 peer"))
   (.log.info* (str "Starting local network '" name "'"))
   (.log.info* (str "N peers = " n.peer))
   (let [command            (or (:command option+)
                                '[cvx])
         controller.genesis 12
         dir                ($.peer/dir option+)
         dir.genesis        (str dir "/0")
         log.level          (or (:log.level option+)
                                :info)
         pipe.genesis       (str name "_0")
         kp+                (loop [acc    []
                                   i.peer 0]
                              (if (< i.peer
                                     n.peer)
                                (recur (conj acc
                                             (.kp.create (.gen (.gen.blob-32)
                                                               {:seed (+ controller.genesis
                                                                         i.peer)})))
                                       (inc i.peer))
                                acc))
         _                  (.log.info* "Starting genesis peer")
         peer.genesis       (.process.run
                              (concat command
                                      [(.cell.str
                                         `(do
                                            (.log.level.set ~log.level)
                                            (let [$.peer (get (.dep.deploy '[$.peer (lib peer)])
                                                              '$.peer)]
                                              (def peer
                                                   (:peer ($.peer/start.genesis ~(.kp.seed (first kp+))
                                                                                {:dir   ~dir.genesis
                                                                                 :peer+ ~(loop [acc    []
                                                                                                i.peer 0]
                                                                                           (if (< i.peer
                                                                                                  n.peer)
                                                                                             (recur (conj acc
                                                                                                          {:key  (.kp.pubkey (get kp+
                                                                                                                                  i.peer))
                                                                                                           :port (+ 18888
                                                                                                                    i.peer)})
                                                                                                    (inc i.peer))
                                                                                             acc))})))
                                              (.log.info* ~(str "Starting worker named '" pipe.genesis "'"))
                                              (.stream.outln :ready)
                                              (.worker.start {:pipe             ~pipe.genesis
                                                              :stream.out.limit ~(:stream.out.limit option+)}))))])
                              {:err (.file.stream.out (str dir.genesis "/err.txt"))})]
     (.a.do*
       (let [code (.a.take (:exit peer.genesis))]
         (if (zero? code)
           (.log.info* "Peer 0 stopped normally")
           (.log.error* (str "Peer 0 stopped with non-zero exit code: " code)))))
     (when-not (= (first (.stream.line (:out peer.genesis)))
                  :ready)
       (fail :SHELL.PEER
             "Problem while starting the genesis peer"))
     (.log.info* "Peer genesis ready")
     (let [n.peer.syncer (dec n.peer)]
       (when (> n.peer.syncer
                0)
         (.log.info* (str "Starting syncer peers"))
         (.log.info* (str "N syncers = " n.peer.syncer))
         (loop [peer.syncer+ []]
           (if (< (count peer.syncer+)
                         n.peer.syncer)
             (recur (conj peer.syncer+
                          (let [i.peer      (inc (count peer.syncer+))
                                dir.syncer  (str dir "/" i.peer)
                                pipe.syncer (str name "_" i.peer)
                                peer.syncer (.process.run
                                              (concat command
                                                      `[(do
                                                          (.log.level.set ~log.level)
                                                          (let [$.peer (get (.dep.deploy '[$.peer (lib peer)])
                                                                            '$.peer)]
                                                            (def peer
                                                                 (:peer ($.peer/start.syncer ~(.kp.seed (get kp+
                                                                                                             i.peer))
                                                                                              {:dir  ~dir.syncer
                                                                                               :port ~(+ 18888
                                                                                                         i.peer)})))
                                                            (.log.info* ~(str "Starting worker named '" pipe.syncer "'"))
                                                            (.stream.outln :ready)
                                                            (.worker.start {:pipe             ~pipe.syncer
                                                                            :stream.out.limit ~(:stream.out.limit option+)})))])
                                              {:err (.file.stream.out (str dir.syncer "/err.txt"))})]
                            (.a.do*
                              (let [code (.a.take (:exit peer.genesis))]
                                (if (zero? code)
                                  (.log.info* (str "Peer " i.peer " stopped normally"))
                                  (.log.error* (str "Peer " i.peer " stopped with non-zero exit code: " code)))))
                            peer.syncer)))
             (reduce (fn [peer+ peer.syncer]
                       (let [i.peer (count peer+)]
                         (.log.info* (str "Awaiting peer " i.peer))
                         (when-not (= (first (.stream.line (:out peer.syncer)))
                                      :ready)
                           (fail :SHELL.PEER
                                 (str "Problem while awaiting peer " i.peer)))
                         (conj peer+
                               peer.syncer)))
                     [peer.genesis]
                     peer.syncer+))))))))
