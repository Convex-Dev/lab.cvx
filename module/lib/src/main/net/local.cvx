{:deploy [$.client.pool (lib client pool)
          $.peer        (lib peer)
          $.sim.load    (lib sim load)]}


;;;;;;;;;; Private helpers


(defn -cmd

  [option+]

  (vec (or (:cmd option+)
           default.cmd)))



(def -ctrl.genesis

  ^:private?

  (inc (long .account.genesis)))



(defn -etch.extract

  ^:private?

  [cmd path]

  (let [result  (.stream.in+
                          (:out
                            (.process.run
                              (conj cmd
                                    `(do
                                       (.db.open ~path)
                                       (.state.switch #12
                                                      (.db.root.read))
                                       (let [peer+ (:peers *state*)]
                                         [(count peer+)
                                          (get-in peer+
                                                  [(:key (account *address*))
                                                   :metadata
                                                   :url])]))))))
       _ (when (empty? result)
           (fail :SHELL.PEER
                 "Unable to extract information about peers from Etch"))
       [n.peer
       url.genesis] (first result)]
    (when-not (str? url.genesis)
      (fail :SHELL.PEER
            "Genesis URL missing"))
    [n.peer
     (first (.reader.form+ (second (split url.genesis
                                          \:))))]))



(defn -kp.peer.seed

  ^:private?

  [i.peer]

  (.kp.seed.dev (+ -ctrl.genesis
                   i.peer)))



(defn -kp.peer.seed+

  ^:private?

  [n.peer]

  (loop [acc    []
         i.peer 0]
    (if (< i.peer
           n.peer)
      (recur (conj acc
                   (-kp.peer.seed i.peer))
             (inc i.peer))
      acc)))



(defn -process.ensure-ready

  ^:private?

  [process i.peer]

  (.log.info* (str "Awaiting peer " i.peer))
  (let [cell+ (.stream.line (:out process))
        error (cond
                ;;
                (empty? cell+)
                (str "Peer " i.peer " stopped before being ready, check logs")
                ;;
                (not (= cell+
                        '(:ready)))
                (str "Peer " i.peer " did not send the approriate signal indicating readiness"))]
    (when error
      (fail :SHELL.PEER
            error)))
  (.log.info* (str "Peer " i.peer " ready to operate"))
  process)



(defn -process.start

  ^:private?

  [cmd path.actor config]

  (let [i.peer   (:i.peer config)
        dir.peer (str (:dir config) "/" i.peer)
        peer     (.process.run
                   (conj cmd
                         `(do
                            (.dep.exec '(lib net local peer))
                            (main (quote ~(assoc config
                                                 :dir        dir.peer
                                                 :path.actor path.actor)))))
                   {:err (.file.stream.out (str dir.peer "/err.txt"))})]
    (.a.do*
       (let [code (.a.take (:exit peer))]
         (if (zero? code)
           (.log.info* (str "Peer " i.peer " stopped normally"))
           (.log.error* (str "Peer " i.peer " stopped with non-zero exit code: " code)))))
    peer))



(defn -state.genesis

  ^:private?


  ([]

   (-state.genesis nil))


  ([option+]

   (let [peer+        (:peer+ option+)
         n.peer       (or (:n.peer option+)
                          (count peer+))
         kp.seed+     (-kp.peer.seed+ n.peer)
         port.genesis (or (:port.genesis option+)
                          .peer.default.port)]
     (loop [acc    []
            i.peer 0]
       (if (< i.peer
              n.peer)
         (recur (conj acc
                      (merge (get peer+
                                  i.peer)
                             {:key  (.kp.pubkey (.kp.create (get kp.seed+
                                                                 i.peer)))
                              :port (+ port.genesis
                                       i.peer)}))
                (inc i.peer))
         {:peer+ acc})))))


;;;;;;;;;; Default values


(def default.cmd

  '[cvx])


;;;;;;;;;; Starting peers


(defn resume

  
  ([name]

   (resume name
           nil))


  ([name option+]

   (.log.info* (str "Resuming local network '" name "'"))
   (let [cmd          (-cmd option+)
         dir          ($.peer/dir option+)
         config       {:dir              dir
                       :log.level        (or (:log.level option+)
                                             :info)
                       :name             name
                       :stream.out.limit (:stream.out.limit option+)}
         _            (.log.info* "Resuming peer 0 (genesis peer)")
         peer.genesis (-process.start cmd
                                      '(lib net local resume)
                                      (assoc config
                                             :i.peer
                                             0))]
     (-process.ensure-ready peer.genesis
                            0)
     (loop [peer.syncer+ []]
       ;; TODO. Would be more robust to query the number of syncers from the genesis peer.
       (let [i.peer (inc (count peer.syncer+))]
         (if (.fs.exists? (str dir "/" i.peer))
           (recur (conj peer.syncer+
                        (-process.start cmd
                                        '(lib net local resume)
                                        (assoc config
                                               :i.peer
                                               i.peer))))
           {:name         name
            :peer+        (reduce (fn [peer+ peer.syncer]
                                    (-process.ensure-ready peer.syncer
                                                           (count peer+))
                                    (conj peer+
                                          peer.syncer))
                                  [peer.genesis]
                                  peer.syncer+)
            :port.genesis (:port (first (.file.read (str dir "/0/config.cvx"))))}))))))



(defn start


  ([name]

   (start name
          nil))


  ([name option+]

   (.log.info* (str "Starting local network '" name "'"))
   (let [cmd           (-cmd option+)
         dir           ($.peer/dir option+)
         log.level     (or (:log.level option+)
                           :info)
         state         (:state option+)
         [n.peer
          port.genesis
          etch.origin] (if (str? state)
                         (do
                           (.log.info* (str "Reusing genesis Etch instance at '" state "'"))
                           (conj (-etch.extract cmd
                                                state)
                                 state))
                         (let [path (str dir "/genesis.etch")]
                           (when-not (etch path
                                           (assoc option+
                                                  :n.peer       3
                                                  :port.genesis 18888))
                             (fail :SHELL.PEER
                                   "Error while generating genesis Etch instance"))
                           [3
                            18888
                            path]))
         _             (do
                         (.log.info* (str "N peers = " n.peer))
                         (.log.info* (str "Genesis port = " port.genesis)))
         config        {:dir              dir
                        :etch.origin      etch.origin
                        :n.max.sibling    (:n.max.sibling option+)
                        :name             name
                        :log.level        (or (:log.level option+)
                                              :info)
                        :poll-delay       (:poll-delay option+)
                        :port.genesis     port.genesis
                        :stream.out.limit (:stream.out.limit option+)}
         _             (.log.info* "Starting peer 0 (genesis peer)")
         peer.genesis  (-process.start cmd
                                       '(lib net local genesis)
                                       (assoc config
                                              :i.peer
                                              0))]
     (-process.ensure-ready peer.genesis
                            0)
     (let [config-2      (if (= (:etch.origin.syncer? option+)
                                false)
                           (do
                             (.log.info* "Etch genesis instance will NOT be copied by syncer peers")
                             (dissoc config
                                     :etch.origin))
                           (do
                             (.log.info* "Etch genesis instance will be copied by syncer peers")
                             config))
           n.peer.syncer (dec n.peer)]
       (if (zero? n.peer.syncer)
         (.log.info* "No syncer peer")
         (do
           (.log.info* (str "Starting syncer peers"))
           (.log.info* (str "N syncers = " n.peer.syncer))))
       (loop [peer.syncer+ []]
         (if (< (count peer.syncer+)
                       n.peer.syncer)
           (recur (conj peer.syncer+
                        (let [i.peer (inc (count peer.syncer+))]
                          (-process.start cmd
                                          '(lib net local syncer)
                                          (assoc config-2
                                                 :i.peer
                                                 i.peer)))))
           {:name         name
            :peer+        (reduce (fn [peer+ peer.syncer]
                                    (-process.ensure-ready peer.syncer
                                                           (count peer+))
                                    (conj peer+
                                          peer.syncer))
                                  [peer.genesis]
                                  peer.syncer+)
            :port.genesis port.genesis}))))))


;;;;;;;;;; Stopping peers


(defn kill


  ([net]

   (kill net
         nil))


  ([net i.peer]

   (let [peer+ (:peer+ net)
         kill- (fn [i.peer]
                 (.log.info* (str "Killing peer " i.peer))
                 (.process.kill (get peer+
                                     i.peer)))]
     (if (nil? i.peer)
       (let [n.peer (count peer+)]
         (loop [i.peer-2 0]
           (when (< i.peer-2
                    n.peer)
             (kill- i.peer-2)
             (recur (inc i.peer-2)))))
       (kill- i.peer)))
   nil))



(defn stop


  ([net]

   (stop net
         nil))


  ([net i.peer]

   (let [peer+ (:peer+ net)
         stop- (fn [i.peer]
                 (.log.info* (str "Initiate clean shutdown of peer " i.peer))
                 (let [[in
                        out] (.worker.pipe+ (str (:name net) "_" i.peer))]
                   (.try.resrc* [in-2  (.file.stream.out in)
                                       (.stream.close in-2)
                                 out-2 (.file.stream.in out)
                                       (.stream.close out-2)]
                     (let [[ok?
                            _key
                            _result] (.worker.exec {:in  in-2
                                                    :out out-2}
                                                   '(do
                                                      (.log.info* "Attempting clean shutdown")
                                                      (.peer.stop peer)
                                                      (.log.info* "Peer stopped")
                                                      :worker.stop))]
                       (when-not ok?
                         (.log.error* (str "Error while trying to cleanly shutdown peer " i.peer)))))))]
     (if (nil? i.peer)
       (let [n.peer (count peer+)]
         (loop [i.peer-2 0]
           (when (< i.peer-2
                    n.peer)
             (stop- i.peer-2)
             (recur (inc i.peer-2)))))
       (stop- i.peer)))
   nil))


;;;;;;;;;; Etch and genesis states


(defn etch


  ([path]

   (etch path
         nil))


  ([path option+]

   (.log.info* (str "Generating genesis Etch instance at '" (.fs.resolve path) "'"))
   (.process.success?
     (.process.run
       (concat (-cmd option+)
               `[(.db.open ~path)
                 (let [prepare ~(:prepare option+)
                       state   (.state.genesis ~(-state.genesis option+))]
                   (.db.root.write
                     (if prepare
                       (.state.core.vanilla (prepare state))
                       state)))
                 nil])))
   path))



(defn state.genesis


  ([]

   (state.genesis nil))


  ([option+]

   (.state.genesis (-state.genesis option+))))


;;;;;;;;;; REPLs


(defn repl.client


  ([net addr]

    (repl.client net
                 addr
                 nil))


  ([net addr option+]

   (.client.repl (merge {:key-pair (.kp.create (.kp.seed.dev addr))
                         :rtt?     true}
                        option+
                        {:address addr
                         :host     "localhost"
                         :port     (let [n.peer       (count (:peer+ net))
                                         port.genesis (:port.genesis net)]
                                     (if (= 1
                                            n.peer)
                                       port.genesis
                                       (+ port.genesis
                                          (.gen (.gen.long.uniform 0
                                                                  (dec n.peer))
                                                {:seed (.time.unix)}))))}))))


(defn repl.peer


  ([net]

   (repl.peer net
              nil))


  ([net i.peer]

   (.worker.repl {:pipe (str (:name net)
                             "_" 
                             (or i.peer
                                 (.gen (.gen.long.uniform 0
                                                          (dec (count (:peer+ net))))
                                       {:seed (.time.unix)})))})))


;;;;;;;;;; Load


(defn load


  ([gen.trx]

   (load nil
         gen.trx))


  ([net gen.trx]

   ($.sim.load/start gen.trx
                     {:port (:port.genesis net)})))
