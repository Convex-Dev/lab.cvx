{:deploy [$.client.pool (lib client pool)
          $.peer        (lib peer)]}


;;;;;;;;;



(defn stop

  [peer+]

  (let [n (count peer+)]
    (loop [i 0]
      (when (< i
               n)
        (.log.info* (str "Killing Peer "
                         i))
        (.process.kill (nth peer+
                            i))
        (recur (inc i)))))
  nil)



(defn repl

  [peer+ i]

  (.worker.repl (nth peer+
                     i)
                {:name (str "peer-" i)}))
                            





(defn client.repl


  ([peer+ i]

   (client.repl peer+
                i
                nil))


  ([peer+ i option+]

   (.client.repl (merge {:rtt? true}
                        option+
                        {:address  (address (+ (long .account.genesis)
                                               1
                                               i))
                         :host     "localhost"
                         :key-pair (:kp (nth peer+
                                             i))
                         :port     (+ 18888
                                      i)}))))


(defn go

  [n]

  (.log.level.set :info)
  (def ps
       (start ;'[java "-Xms10G" "-Xmx20G" "-jar" "/Users/adam/Code/convex/clj/tool/private/target/shell.uber.jar"]
              '[cvx]
              {:dir "/tmp/net"
               :n   n})))




(defn code.account+

  [n seed]

  (loop [acc []
         i   0]
    (if (< i
           n)
      (recur (conj acc
                   `(transfer (deploy '(set-key ~(.kp.pubkey (.kp.create (.gen (.gen.blob-32)
                                                                               {:seed (+ seed
                                                                                         i)})))))
                              100000000))
             (inc i))
      (cons 'do
            acc))))



(defn trx.account+

  [peer+ n]

  (when-not (.db.path)
    (.db.open (.fs.tmp)))
  (.try.resrc* [client (.client.connect)
                       (.client.close client)]
    (loop [seq         (.a.take (.client.sequence client
                                                  #11))
           n.remaining n]
      (when (> n.remaining
               0)
        (let [n.create (min n.remaining
                            250)]
          (.log.info* (str "Creating " n.create " accounts"))
          (let [result (.a.take
                         (.client.transact client
                                           (:kp (first peer+))
                                           (.trx.new.invoke #12
                                                            (code.account+ n.create
                                                                           (+ 45
                                                                              (- n
                                                                                 n.remaining)
                                                                              (dec (count peer+))))
                                                                              {:sequence seq}))
                         10000
                         :timeout)]
            (when (or (= result
                         :timeout)
                      (:error result))
              (.log.fatal* [:account-creation result])
              (fail :SETUP
                    "Unable to create accounts")))
          (recur (inc seq)
                 (- n.remaining
                    n.create)))))))
 


(defn load

  [peer+ n.peer n.account n.client]

  (let [client-pool ($.client.pool/connect.range n.client
                                                 n.peer)]
    (loop [acc []
           i   0]
      (if (< i
             n.account)
        (recur (conj acc
                     (.a.do*
                       (let [addr.long (+ 45
                                          (dec (count peer+))
                                          i)
                             addr      (address addr.long)
                             client    (nth client-pool
                                            (mod i
                                                 (count client-pool)))
                             kp        (.kp.create (.gen (.gen.blob-32)
                                                         {:seed addr.long}))]
                         (loop [i 1]
                           (let [trx      (.kp.sign kp
                                                    (.trx.new.invoke addr
                                                                     `(def foo
                                                                           ~(.gen (.gen.long)))
                                                                     {:sequence i}))
                                 [rtt
                                  result] (.time.do*
                                            (.a.take (.client.transact client
                                                                       trx)))]
                             (.log.report* [addr (/ rtt 1e6) result])
                             ;(.time.sleep (.gen (.gen.long.uniform 0
                             ;                                      50)))
                             (recur
                               (if (= (:error result)
                                      :SEQUENCE)
                                 (.a.take (.client.sequence client
                                                            addr))
                                 (inc i))))))))
               (inc i))
        acc))))



(defn main

  [n.peer n.client]

  (let [peer+ (go n.peer)]
    (trx.account+ peer+
                  n.client)
    (load peer+
          n.peer
          n.client
          n.client)))









(defn kp.seed+

  [n.peer]

  (let [controller.genesis 12]
    (loop [acc    []
           i.peer 0]
      (if (< i.peer
             n.peer)
        (recur (conj acc
                     (.gen (.gen.blob-32)
                           {:seed (+ controller.genesis
                                     i.peer)}))
               (inc i.peer))
        acc))))



(defn start-worker

  [name i.peer stream.out.limit]

  (.log.info* "Peer ready to operate")
  (.stream.outln :ready)
  (let [pipe (str name "_" i.peer)]
    (.log.info* (str "Starting worker named '" pipe "'"))
    (.worker.start {:pipe             pipe
                    :stream.out.limit stream.out.limit})))


(defn process.ensure-ready

  [process i.peer]

  (.log.info* (str "Awaiting peer " i.peer))
  (let [cell+ (.stream.line (:out process))
        error (cond
                ;;
                (empty? cell+)
                (str "Peer " i.peer " stopped before being ready, check logs")
                ;;
                (not (= cell+
                        '(:ready)))
                (str "Peer " i.peer " did not send the approriate signal indicating readiness"))]
    (when error
      (fail :SHELL.PEER
            error)))
  (.log.info* (str "Peer " i.peer " ready to operate"))
  process)



(defn monitor-exit

  [process i.peer]

  (.a.do*
       (let [code (.a.take (:exit process))]
         (if (zero? code)
           (.log.info* (str "Peer " i.peer " stopped normally"))
           (.log.error* (str "Peer " i.peer " stopped with non-zero exit code: " code)))))
  process)






(defn process

  [command config sym.fn]

  (let [i.peer   (:i.peer config)
        dir.peer (str (:dir config) "/" i.peer)
        peer     (.process.run
                   (conj command
                         (.cell.str
                           `(let [$.net.local (get (.dep.deploy '[$.net.local (lib net local)])
                                                   '$.net.local)]
                              ((lookup $.net.local
                                       ~sym.fn)
                               ~(assoc config
                                       :dir
                                       dir.peer)))))
                   {:err (.file.stream.out (str dir.peer "/err.txt"))})]
    (monitor-exit peer
                  (:i.peer config))
    peer))

            



(defn start


  ;; TODO. Allow preparing genesis state.
  ;;       Simplify providing pubkey for genesis peer.
  ;;       Allow resuming networks.


  ([name n.peer]

   (start name
          n.peer
          nil))


  ([name n.peer option+]

   (when (< n.peer
            1)
     (fail :ARGUMENT
           "Must run at least 1 peer"))
   (.log.info* (str "Starting local network '" name "'"))
   (.log.info* (str "N peers = " n.peer))
   (let [command            (vec (or (:command option+)
                                     '[cvx]))
         dir                ($.peer/dir option+)
         log.level          (or (:log.level option+)
                                :info)
         config             {:dir              dir
                             :kp.seed+         (kp.seed+ n.peer)
                             :name             name
                             :log.level        (or (:log.level option+)
                                                   :info)
                             :port.genesis     (or (:port.genesis option+)
                                                   18888)
                             :stream.out.limit (:stream.out.limit option+)}
         _                  (.log.info* "Starting peer 0 (genesis peer)")
         peer.genesis       (process command
                                     (assoc config
                                            :i.peer
                                            0)
                                     'start.genesis)]
     (process.ensure-ready peer.genesis
                           0)
     (let [n.peer.syncer (dec n.peer)]
       (when (> n.peer.syncer
                0)
         (.log.info* (str "Starting syncer peers"))
         (.log.info* (str "N syncers = " n.peer.syncer))
         (loop [peer.syncer+ []]
           (if (< (count peer.syncer+)
                         n.peer.syncer)
             (recur (conj peer.syncer+
                          (let [i.peer (inc (count peer.syncer+))]
                            (process command
                                     (assoc config
                                            :i.peer
                                            i.peer)
                                     'start.syncer))))
             (reduce (fn [peer+ peer.syncer]
                       (process.ensure-ready peer.syncer
                                             (count peer+))
                       (conj peer+
                              peer.syncer))
                     [peer.genesis]
                     peer.syncer+))))))))




(defn start.genesis

  [config]

  (let [kp.seed+     (:kp.seed+ config)
        n.peer       (count kp.seed+)
        port.genesis (:port.genesis config)]
    (.log.level.set (:log.level config))
    (def peer
         (:peer ($.peer/start.genesis (first kp.seed+)
                                      {:dir   (:dir config)
                                       :peer+ (loop [acc    []
                                                     i.peer 0]
                                                (if (< i.peer
                                                       n.peer)
                                                  (recur (conj acc
                                                               {:key  (.kp.pubkey (.kp.create (get kp.seed+
                                                                                                   i.peer)))
                                                                :port (+ port.genesis
                                                                         i.peer)})
                                                         (inc i.peer))
                                                  acc))
                                        :port port.genesis})))
    (start-worker (:name config)
                  0
                  (:stream.out.limit config))))



(defn start.syncer

  [config]

  (.log.level.set (:log.level config))
  (let [i.peer       (:i.peer config)
        port.genesis (:port.genesis config)]
    (def peer
         (:peer ($.peer/start.syncer (get (:kp.seed+ config)
                                          i.peer)
                                     {:dir  (:dir config)
                                      :port (+ port.genesis
                                               i.peer)})))
    (start-worker (:name config)
                  i.peer
                  (:stream.out.limit config))))
