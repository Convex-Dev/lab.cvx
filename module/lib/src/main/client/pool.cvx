{}

;;;;;;;;;;


(defn connect


  ([end-point+]

   (start nil
          end-point+))


  ([n.client end-point+]

   (when (and n.client
              (< n.client
                 1))
     (fail :ARGUMENT
           "Must start at least 1 client"))
   (when (empty? end-point+)
     (fail :ARGUMENT
           "Must provide at least 1 end point"))
   (when-not (.db.path)
     (.db.open (.fs.tmp)))
   (let [n.end-point (count end-point+)
         n.client-2  (or n.client
                         n.end-point)]
     (loop [acc []
            i   0]
       (if (< i
              n.client-2)
         (recur (conj acc
                      (.client.connect (nth end-point+
                                            (mod i
                                                 n.end-point))))
                (inc i))
         acc)))))



(defn connect.range


  ([n.client n.peer]

   (connect.range n.client
                  n.peer
                  nil))


  ([n.client n.peer option+]

   (let [base.port (or (:base.port option+)
                       .peer.default.port)
         host      (:host option+)]
     (connect n.client
              (loop [acc    []
                     i.peer 0]
                (if (< i.peer
                       n.peer)
                  (recur (conj acc
                               {:host host
                                :port (+ base.port
                                         i.peer)})
                         (inc i.peer))
                  acc))))))



(defn close

  [pool]

  (reduce (fn [_ cnx]
            (.client.close cnx))
          nil
          pool)
  nil)
